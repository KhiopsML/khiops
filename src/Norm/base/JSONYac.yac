%{
// Parser de json, inspire de la grammaire  de reference https://www.json.org/json-en.html

#include "Object.h"
#include "ALString.h"
#include "TextService.h"
#include "JSONObject.h"
#include "HugeBuffer.h"

// Declaration du lexer utilise
int jsonlex();

// Methode de gestion des erreurs
void jsonerror(char const *fmt);
const ALString jsonPrintableValue(const ALString& sValue);

// Valeur json principale a creer a l'issue du parsing
static JSONValue* globalParsedJSONValue=NULL;

// Vecteur de m'essage d'erreur principal a utiliser quand on parse une chaine de caractere, et non un fichier
// Cet vecteur est a positionner avant le debut du parsing
static StringVector* svGlobalParsingErrorMessages=NULL;

// Work around a bug in the relation between bison and GCC 3.x:
#if defined (__GNUC__) && 3 <= __GNUC__
#define __attribute__(arglist)
#endif

// Nombre total d'erreurs de parsing
static int nJsonFileParsingErrorNumber = 0;

// Desactivation de warnings pour le Visual C++
#ifdef __MSC__
#pragma warning(disable : 4702) // C4702: unreachable code (mal gere par Visual C++)
#endif                          // __MSC__

#define YY_STATIC

// Debugging YAC

// Debugging YAC
// Ajouter ici les instruction suivantes
//   #define YYDEBUG 1 
//   extern char   *yyptok(int i); 
// Ajouter l'instruction yydebug = 1 dans le code d'une action du fichier .lex ou .yac

%}

%define api.prefix {json}

%union {
  ALString* sValue;
  double dValue;
  boolean bValue;
  JSONValue* jsonValue;
  JSONObject* jsonObject;
  JSONArray* jsonArray;
  JSONMember* jsonMember;
};

%token <sValue>    STRINGVALUE
%token <dValue>    NUMBERVALUE
%token <bValue>    BOOLEANVALUE
%token <sValue>    STRINGERROR
%token <sValue>    ERROR
%token NULLVALUE 
%type <jsonValue> jsonResult
%type <jsonValue> value
%type <jsonObject> object
%type <jsonObject> members
%type <jsonMember> member
%type <jsonArray> array
%type <jsonArray> values


// Parametrage du destructeur a appeler en cas d'erreur
%destructor {if ($$ != NULL) delete $$; $$=NULL;} <sValue> <jsonValue> <jsonObject> <jsonArray> <jsonMember>


%start jsonResult

%%

jsonResult: value
    {
		JSONValue* jsonValue = $1;
		
		require(globalParsedJSONValue == NULL);

		// On indique que l'objet construit est NULL, pour qu'il ne soit pas detruit par le parser
		$$ = NULL;
		globalParsedJSONValue = jsonValue;
	}
	| error
	{
		$$ = NULL;
		YYABORT;
	}
	;


value: object     { $$ = $1; } 
	| array   { $$ = $1; } 
	| STRINGVALUE  
	{ 
	    ALString* sValue = $1;
		JSONString* jsonString;
		
		// Creation d'une valeur chaine de caractere
		jsonString = new JSONString;
		$$ = jsonString;

		// Alimentation
		jsonString->SetString(*sValue);
		delete sValue;
	}
	| NUMBERVALUE
	{ 
		double dValue = $1;
		JSONNumber* jsonNumber;
		
		// Creation d'une valeur chaine de caractere
		jsonNumber = new JSONNumber;
		$$ = jsonNumber;

		// Alimentation
		jsonNumber->SetNumber(dValue);
	}
	| BOOLEANVALUE
	{ 
		boolean bValue = $1;
		JSONBoolean* jsonBoolean;
		
		// Creation d'une valeur chaine de caractere
		jsonBoolean = new JSONBoolean;
		$$ = jsonBoolean;

		// Alimentation
		jsonBoolean->SetBoolean(bValue);
	}
	| NULLVALUE
	{ 
		JSONNull* jsonNull;
		
		// Creation d'une valeur chaine de caractere
		jsonNull = new JSONNull;
		$$ = jsonNull;
	}
	| STRINGERROR  
	{
	    ALString* sError = $1;

		// Message d'erreur
		jsonerror("Invalid json string \"" + jsonPrintableValue(*sError) + "\" with non-utf8 encoding");

		// Nettoyage et sortie
		delete sError;
		$$ = NULL;
		YYABORT;
	}
	| ERROR  
	{ 
	    ALString* sError = $1;
		ALString sValueError;

		// Message d'erreur, avec indication de la valeur sauf si elle se reduit au caractete '"'
		if (*sError != "\"")
			sValueError = " \"" + jsonPrintableValue(*sError) + "\"";
		jsonerror("Invalid json value" + sValueError);

		// Nettoyage et sortie
		delete sError;
		$$ = NULL;
		YYABORT;
	}
	;

object: '{' '}'            
	{ $$ = new JSONObject; }
	| '{' members '}'  
	{ $$ = $2; }
	;

members: member                    
	{ 
		JSONMember* member = $1;
		JSONObject* jsonObject;
		
		// Creation d'un objet json
		jsonObject = new JSONObject;
		$$ = jsonObject;
		
		// Alimentation avec un premier membre d'objet
		jsonObject->AddMember(member);
	}
	| members ',' member
	{ 
		JSONObject* jsonObject = $1;
		JSONMember* member = $3;
		ALString sJsonKey;
		
		// On recupere l'objet json en cours
		$$ = jsonObject;
		
		// Ajout d'un nouveau membre d'objet, s'il n'en existe pas deja un du meme nom
		if (jsonObject->LookupMember(member->GetKey()) == NULL)
			jsonObject->AddMember(member);
		// Erreur sinon
		else
		{
			TextService::CToJsonString(member->GetKey(), sJsonKey);
			jsonerror("Duplicate key \"" + jsonPrintableValue(sJsonKey) + "\" in json object");

			// Nettoyage et sortie
			delete member;
			delete jsonObject;
			$$ = NULL;
			YYABORT;
		}
	}
	| STRINGERROR  
	{ 
	    ALString* sError = $1;

		// Message d'erreur
		jsonerror("Invalid json key \"" + jsonPrintableValue(*sError) + "\" with non-utf8 encoding");

		// Nettoyage et sortie
		delete sError;
		$$ = NULL;
		YYABORT;
	}
	| ERROR  
	{ 
	    ALString* sError = $1;
		ALString sValueError;

		// Message d'erreur, avec indication de la valeur sauf si elle se reduit au caractete '"'
		if (*sError != "\"")
			sValueError = " \"" + jsonPrintableValue(*sError) + "\"";
		jsonerror("Invalid json key" + sValueError);

		// Nettoyage et sortie
		delete sError;
		$$ = NULL;
		YYABORT;
	}
	;

member: STRINGVALUE ':' value 	 
	{ 
	    ALString* sKey = $1;
		JSONValue* jsonValue = $3;
		JSONMember* member;

		// Creation d'un membre d'objet
		member = new JSONMember;
		$$ = member;

		// Alimentation
		member->SetKey(*sKey);
		member->SetValue(jsonValue);
		delete sKey;
	}
	;

array: '[' ']'
	{ $$ = new JSONArray; }
	| '[' values ']'  
	{ $$ = $2; }
	;

values: value
	{ 
		JSONValue* jsonValue = $1;
		JSONArray* jsonArray;
		
		// Creation d'un tableau de valeur
		jsonArray = new JSONArray;
		$$ = jsonArray;
		
		// Alimentation avec un premier membre d'objet
		jsonArray->AddValue(jsonValue);
	}
	| values ',' value   
	{ 
		JSONArray* jsonArray = $1;
		JSONValue* jsonValue = $3;
		
		// On recupere le tableau en cours
		$$ = jsonArray;
		
		// Ajout d'un nouveau membre d'objet
		jsonArray->AddValue(jsonValue);
	}
	;

%%


#include "JSONLex.inc"

// default yyerror for YACC and LEX
void jsonerror(char const *fmt)
{
  char sErrorLine[20];
  ALString sLabel;

  nJsonFileParsingErrorNumber++;
  
  // Cas du parsing d'une chaine de caracteres
  if (svGlobalParsingErrorMessages != NULL)
  {
    svGlobalParsingErrorMessages->Add(fmt);
  }
  // Parsing d'un fichier sinon, avec infos de numero de ligne
  else
  {
    snprintf(sErrorLine, sizeof(sErrorLine), "Line %d", yylineno);
    sLabel = fmt;
    Global::AddError("Read json file",
                      sErrorLine,
                      sLabel);
  }
}

const ALString jsonPrintableValue(const ALString& sValue)
{
	const int nMaxPrintableLength = 30;

	if (sValue.GetLength() <= nMaxPrintableLength)
		return sValue;
	else
		return sValue.Left(nMaxPrintableLength) + "...";
}

int jsonparse();

// Implementation de la methode de parsing de string
JSONValue* JSONValue::GlobalReadString(const char* sValue, int nValueLength, StringVector* svParsingErrorMessages)
{
	JSONValue* resultJSONValue;
	char* sBuffer;

	require(globalParsedJSONValue == NULL);

	// Initialisation du vecteur collectant les messages d'erreur
	assert(svGlobalParsingErrorMessages == NULL);
	svParsingErrorMessages->SetSize(0);
	svGlobalParsingErrorMessages = svParsingErrorMessages;

	// Activation du nombre max d'erreurs a afficher
	nJsonFileParsingErrorNumber = 0;
	Global::ActivateErrorFlowControl();

	// Positionnement du buffer a parser par la variable yyin de LEX
	jsonlineno = 1;

	// On passe par un buffer de grande taille deja disponible pour eviter 
	// de sous-traiter les allocation de buffer a lex
	// On passe par un buffer dont les deux dernier caracteres sont '\0', selon le protocole lex
	sBuffer = GetHugeBuffer(nValueLength+2);
	memcpy(sBuffer, sValue, nValueLength);
	sBuffer[nValueLength] = '\0';
	sBuffer[nValueLength+1] = '\0';

	// On passe par un buffer dont les deux dernier caracteres sont '\0', selon le protocole lex
	// Cela nous permet de gerer la memoire, plutot que confier les allocation a lex via la fonction json_scan_string
	json_scan_buffer(sBuffer, nValueLength+2);

	// Parsing
	jsonparse();

	// Cleaning lexer
	jsonlex_destroy();

	// Nettoyage si erreurs
	if (nJsonFileParsingErrorNumber > 0)
	{
		// Destruction de l'objet construit
		if (globalParsedJSONValue != NULL)
		{
			delete globalParsedJSONValue;
			globalParsedJSONValue = NULL;
		}
	}
	nJsonFileParsingErrorNumber = 0;

	// Desactivation du nombre max d'erreurs a afficher
	Global::DesactivateErrorFlowControl();

	// Acces au resultat
	resultJSONValue = globalParsedJSONValue;

	// Nettoyage
	globalParsedJSONValue = NULL;
	svGlobalParsingErrorMessages = NULL;

	ensure(globalParsedJSONValue == NULL);
	return resultJSONValue;
}

// Implementation de la methode de parsing de fichier
JSONValue* JSONValue::GlobalReadFile(const ALString& sFileName)
{
	JSONValue* resultJSONValue;
	boolean bOk = true;
	FILE* fFile;
	ALString sLocalFileName;

	require(globalParsedJSONValue == NULL);
	
	// Erreur si pas de nom de fichier
	fFile = NULL;
	if (sFileName == "")
	{
		Global::AddError("Read json file", "", "Missing file name");
		bOk = false;
	}
	// Sinon, ouverture du fichier
	else
	{ 
		// Copie depuis un fichier distant si necessaire
		bOk = PLRemoteFileService::BuildInputWorkingFile(sFileName, sLocalFileName);
		if (bOk)
			bOk = FileService::OpenInputBinaryFile(sLocalFileName, fFile);
	}

	// On continue si fichier ouvert correctement
	if (bOk)
	{
		assert(fFile != NULL);

		// Activation du nombre max d'erreurs a afficher
		nJsonFileParsingErrorNumber = 0;
		Global::ActivateErrorFlowControl();

		// Positionnement du fichier a parser par la variable yyin de LEX
		jsonlineno = 1;
		jsonrestart(fFile);
		
		// Parsing
		jsonparse();

		// Cleaning lexer
		jsonlex_destroy();

		// Fermeture du fichier
		FileService::CloseInputBinaryFile(sLocalFileName, fFile);
	
		// Si fichier distant, on supprime la copie locale
		PLRemoteFileService::CleanInputWorkingFile(sFileName, sLocalFileName);

		// Desactivation du nombre max d'erreurs a afficher
		Global::DesactivateErrorFlowControl();

		// Nettoyage si erreurs
		if (nJsonFileParsingErrorNumber > 0)
		{
			// Destruction de l'objet construit
			if (globalParsedJSONValue != NULL)
			{
				delete globalParsedJSONValue;
				globalParsedJSONValue = NULL;
			}

			// En cas d'erreur, ajout d'une ligne blanche pour separer des autres logs
			Global::AddError("Read json file", sFileName, "Errors detected during parsing, read operation cancelled");
			bOk = false;
		}
		nJsonFileParsingErrorNumber = 0;
	}

	// Acces au resultat
	resultJSONValue = globalParsedJSONValue;

	// Nettoyage
	globalParsedJSONValue = NULL;

	ensure(globalParsedJSONValue == NULL);
	return resultJSONValue;
}

void JSONValue::SetLineno(int nValue)
{
	jsonlineno = nValue;
}

int JSONValue::GetLineno()
{
	return jsonlineno;
}

void JSONValue::Restart(FILE* inputFile) 
{
	jsonrestart(inputFile);
}

int JSONValue::Lex(JSONSTYPE* jsonValue)
{
	int nToken;

	require(jsonValue != NULL);

	// Lecture du token, puis de sa valeur
	nToken = jsonlex();
	*jsonValue = jsonlval;
	return nToken;
}

int JSONValue::LexDestroy()
{
	return jsonlex_destroy();
}


