%{

/* ATTENTION: les regles openparenthesis et closeparenthesis generent             */
/* 3 shift/reduce conflicts et 15 reduce/reduce conflicts                         */
/* La regle kwclassBegin genere 1 reduce/reduce conflict supplementaire           */
/* Attention: modifier ces regles en cas d'evolution du parser                    */
/* Ces regles ne sont utiles que pour le diagnostique des erreurs de parenthesage */
/* ou de rattrapage sur declaration d'attribut erronee                            */
/* Ces regles sont reperables par le mot cle ERRORMGT                             */


#include "KWClassDomain.h"
#include "KWClass.h"
#include "KWContinuous.h"
#include "KWDerivationRule.h"
#include "KWStructureRule.h"
#include "KWMetaData.h"

/* Declaration du lexer utilise */
void yyerror(char const *fmt);
void yyerrorWithLineCorrection(char const *fmt, int nDeltaLineNumber);
int yylex();

/* Work around a bug in the relation between bison and GCC 3.x: */
#if defined (__GNUC__) && 3 <= __GNUC__
#define __attribute__(arglist)
#endif

/* Domaine de classe courant a utiliser pendant la lecture d'un fichier. */
/* Ce domaine est positionner par la methode Load de KWClassDomain       */
static KWClassDomain* kwcdLoadDomain=NULL;

/* Classe courante a utiliser pendant la lecture d'un fichier.     */
/* Ce domaine est positionner par la methode Load de KWClassDomain */
static KWClass* kwcLoadCurrentClass=NULL;

/* Dictionnaire des classes referencees creees a la volee lorsqu'elles sont      */
/* utilisees, mais non crees.                                                    */
/* On rajoute les classes referencees non crees, et on retire les classes crees. */
static ObjectDictionary* odReferencedUncreatedClasses=NULL;

/* Nombre total d'erreurs de parsing */
static int nFileParsingErrorNumber = 0;


#define YY_STATIC

/* Debugging YAC */

/*
#define YYDEBUG 1 
extern char   *yyptok(int i); 
*/

%}

%union {
  Continuous cValue;
  ALString* sValue;
  boolean bValue;
  StringVector* svValue;
  KWDerivationRule* kwdrValue;
  KWDerivationRuleOperand* kwdroValue;
  KWClass* kwcValue;
  KWAttribute* kwaValue;
  ObjectArray* oaAttributes;
  KWMetaData* kwmdMetaData;
  int nValue;
};


%token <sValue>    BASICIDENTIFIER
%token <sValue>    EXTENDEDIDENTIFIER
%token <cValue>    CONTINUOUSLITTERAL
%token <sValue>    STRINGLITTERAL
%token <sValue>    LABEL 
%token <sValue>    APPLICATIONID 
%token CLASS 
%token CONTINUOUSTYPE
%token SYMBOLTYPE
%token OBJECTTYPE
%token OBJECTARRAYTYPE
%token ROOT
%token UNUSED
%token DATETYPE
%token TIMETYPE
%token TIMESTAMPTYPE
%token TIMESTAMPTZTYPE
%token TEXTTYPE
%token TEXTLISTTYPE
%token STRUCTURETYPE

%type <nValue> CLASS 
%type <nValue> CONTINUOUSTYPE
%type <nValue> SYMBOLTYPE
%type <nValue> OBJECTTYPE
%type <nValue> OBJECTARRAYTYPE
%type <sValue> IDENTIFIER
%type <sValue> SIMPLEIDENTIFIER
%type <sValue> comments
%type <sValue> applicationids
%type <sValue> bigstring
%type <sValue> refIdentifier
%type <bValue> rootDeclaration
%type <bValue> usedDeclaration
%type <nValue> typeDeclaration
%type <kwcValue> kwclassHeader
%type <kwcValue> kwclassBegin
%type <kwaValue> kwattributeDeclaration
%type <oaAttributes> oaAttributeArrayDeclaration
%type <kwdrValue> usedDerivationRule
%type <kwdrValue> referenceRule
%type <kwdrValue> referenceRuleBody
%type <kwdrValue> derivationRule
%type <kwdrValue> derivationRuleBody
%type <kwdrValue> derivationRuleHeader
%type <kwdrValue> derivationRuleBegin
%type <kwdroValue> derivationRuleOperand
%type <svValue> keyFields
%type <svValue> keyFieldList
%type <kwmdMetaData> metaData


/* Parametrage du destructeur a appeler en cas d'erreur, sauf pour les KWClass <kwcValue> qui sont integree dans des KWClassDomain */
%destructor {if ($$ != NULL) delete $$; $$=NULL;} <sValue> <svValue> <kwdrValue> <kwdroValue> <oaAttributes> <kwmdMetaData> <kwaValue>



%start kwclassFile

%%

IDENTIFIER:
	  SIMPLEIDENTIFIER
        {
          $$ = $1;
        }
	| EXTENDEDIDENTIFIER
        {
          $$ = $1;
        }
	;

SIMPLEIDENTIFIER:
	  BASICIDENTIFIER
        {
          $$ = $1;
        }
	|	CLASS
        {
          $$ = new ALString("Dictionary");
        }
	|	CONTINUOUSTYPE
		{
          $$ = new ALString("Numerical");
		}
	|	SYMBOLTYPE
		{
          $$ = new ALString("Categorical");
		}
	|	OBJECTTYPE
		{
          $$ = new ALString("Entity");
		}
	|	OBJECTARRAYTYPE
		{
          $$ = new ALString("Table");
		}
	|	ROOT
		{
          $$ = new ALString("Root");
		}
	|	UNUSED
		{
          $$ = new ALString("Unused");
		}
	|	DATETYPE
		{
          $$ = new ALString("Date");
		}
	|	TIMETYPE
		{
          $$ = new ALString("Time");
		}
	|	TIMESTAMPTYPE
		{
          $$ = new ALString("Timestamp");
		}
	|	TIMESTAMPTZTYPE
		{
          $$ = new ALString("TimestampTZ");
		}
	|	TEXTTYPE
		{
          $$ = new ALString("Text");
		}
	|	TEXTLISTTYPE
		{
          $$ = new ALString("TextList");
		}
	|	STRUCTURETYPE
		{
          $$ = new ALString("Structure");
		}
	;
    
kwclassFile: applicationids kwclasses comments
    {
	  /* On ignore l'identification d'application */
	  if ($1 != NULL)
	    delete $1;

	  /* On ignore les commentaires en fin de fichier */
	  if ($3 != NULL)
	    delete $3;
	}
	;

kwclasses:
    kwclasses kwclass
  | kwclasses error 
      { yyerror("Error outside the definition of a dictionary"); 
	    YYABORT; }
  | /* NULL */
  ;

kwclass: kwclassBegin '}' semicolon
		{
		  /* La completion des informations de type (CompleteTypeInfo) est centralisee */
		  /* au niveau du domaine en fin de parsing */

		  /* Reinitialisation de la classe courante */
  		  kwcLoadCurrentClass = NULL;
		}
	;

kwclassBegin: kwclassHeader comments
		{
		  /* On ignore les premiers comemntaires */
		  if ($2 != NULL)
		    delete $2;
		  assert(kwcLoadCurrentClass == $1);
		  $$ = $1;
		}
	| kwclassBegin kwattributeDeclaration
        {
		  KWClass* kwcClass=$1;
		  KWAttribute* attribute=$2;
		  assert(kwcLoadCurrentClass == $1);

		  /* Si attribut non valide: on ne fait rien */
		  if (attribute == NULL)
		    ; 
		  /* Si classe non valide, supression de l'attribut */
		  else if (kwcClass == NULL)
		    delete attribute;
	      /* Sinon, test de validite du nom de l'attribut */
		  else if (! kwcClass->CheckName(attribute->GetName(), kwcClass))
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Incorrect variable name", -1);
			delete attribute;
		  }
		  /* Test de non existence parmi les attributs */
		  else if (kwcClass->LookupAttribute(attribute->GetName()) != NULL)
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Variable name already used (" + attribute->GetName() + ")", -1);
			delete attribute;
  		  }
		  /* Test de non existence parmi les blocs */
		  else if (kwcClass->LookupAttributeBlock(attribute->GetName()) != NULL)
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Variable name already used by a block (" + attribute->GetName() + ")", -1);
			delete attribute;
  		  }
		  /* Si OK, d'insertion */
		  else
		  {
		    kwcClass->InsertAttribute(attribute);
		  }

		  $$ = kwcClass;       
		 }
	| kwclassBegin '{' comments oaAttributeArrayDeclaration '}' IDENTIFIER usedDerivationRule semicolon metaData comments
		{
		  KWClass* kwcClass=$1;
		  KWAttributeBlock* attributeBlock;
		  ObjectArray* oaAttributes = $4;
  		  ALString sBlockName;
		  KWAttribute* firstAttribute;
		  KWAttribute* lastAttribute;
		  KWDerivationRule* rule = $7;
		  assert(kwcLoadCurrentClass == $1);
		  check(oaAttributes);

		  /* On ignore les premiers comemntaires */
		  if ($3 != NULL)
		    delete $3;

		  /* Nom du bloc */
		  if ($6 != NULL)
		    sBlockName = *($6);

		  /* Cas d'un bloc avec au moins un attribut valide */
		  if (oaAttributes->GetSize() > 0)
		  {
	        /* Test de validite du nom de l'attribut */
		    if (! kwcClass->CheckName(sBlockName, kwcClass))
		    {
		      yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			  ": Incorrect sparse variable block name (" + sBlockName + ")", -1);
  		    }
			/* Test de non existence parmi les attributs */
		    else if (kwcClass->LookupAttribute(sBlockName) != NULL)
		    {
		      yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			  ": Sparse variable block name already used by a variable (" + sBlockName + ")", -1);
  		    }
			/* Test de non existence parmi les blocs */
		    else if (kwcClass->LookupAttributeBlock(sBlockName) != NULL)
		    {
		      yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			  ": Sparse variable block name already used by a block (" + sBlockName + ")", -1);
  		    }
 	        /* Creation du bloc dans la classe */
			else
			{
			  /* Creation du bloc */
		      firstAttribute = cast(KWAttribute*, oaAttributes->GetAt(0));
		      lastAttribute = cast(KWAttribute*, oaAttributes->GetAt(oaAttributes->GetSize()-1));
		      attributeBlock = kwcClass->CreateAttributeBlock(sBlockName, firstAttribute, lastAttribute);

			  /* Parametrage du bloc */
			  attributeBlock->SetDerivationRule(rule);
			  if ($9 != NULL)
			    attributeBlock->GetMetaData()->CopyFrom($9);
  		      if ($10 != NULL)
			    attributeBlock->SetLabel(*($10));

			  /* On marque la rule a NULL pour indiquer qu'elle est utilisee */
			  rule = NULL;
			}
		  }

	      /* Destruction de l'eventuelle regle si non utilisee */
		  if (rule != NULL)
		    delete rule;

		  /* Tous les attributs du tableau ont deja ete inseres dans la classe */
		  // On se contente de detruire le tableau */
		  delete oaAttributes;
		  
		  /* Nettoyage */
		  if ($6 != NULL)
		    delete $6;
		  if ($9 != NULL)
		    delete $9;
		  if ($10 != NULL)
		    delete $10;
		  
		  $$ = kwcClass;
		  }
	| kwclassBegin '{' comments '}' IDENTIFIER usedDerivationRule semicolon metaData comments
		{
		  KWClass* kwcClass=$1;

		  /* Message d'erreur */
		  yyerror("Empty sparse variable block not allowed");

		  /* Nettoyage */
		  if ($3 != NULL)
		    delete $3;
		  delete $5;
		  if ($6 != NULL)
		      delete $6;
		  if ($8 != NULL)
		    delete $8;
		  if ($9 != NULL)
		    delete $9;
		  $$ = kwcClass;
		  }
	| kwclassBegin error 
	    {
		  /* ERRORMGT */
		  /* Attention: cette regle qui permet une gestion des erreurs amelioree */
		  /* genere un conflit reduce/reduce */
		  kwcLoadCurrentClass = NULL;
		  YYABORT;
		}
       	;

oaAttributeArrayDeclaration : 
	  oaAttributeArrayDeclaration kwattributeDeclaration
        {
		  ObjectArray* oaAttributes = $1;
		  KWAttribute* attribute=$2;
		  KWClass* kwcClass=kwcLoadCurrentClass;
		  check(oaAttributes);

		  /* Si attribut non valide: on ne fait rien */
		  if (attribute == NULL)
		    ; 
		  /* Si classe non valide, supression de l'attribut */
		  else if (kwcClass == NULL)
		    delete attribute;
	      /* Sinon, test de validite du nom de l'attribut */
		  else if (! kwcClass->CheckName(attribute->GetName(), kwcClass))
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Incorrect variable name (" + attribute->GetName() + ")", -1);
			delete attribute;
		  }
		  /* Test de non existence parmi les attributs */
		  else if (kwcClass->LookupAttribute(attribute->GetName()) != NULL)
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Variable name already used (" + attribute->GetName() + ")", -1);
			delete attribute;
  		  }
		  /* Test de non existence parmi les blocs */
		  else if (kwcClass->LookupAttributeBlock(attribute->GetName()) != NULL)
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Variable name already used by a block (" + attribute->GetName() + ")", -1);
			delete attribute;
  		  }
		  /* Si OK, d'insertion */
		  else
		  {
		    kwcClass->InsertAttribute(attribute);
		    oaAttributes->Add(attribute);
		  }

		  $$ = oaAttributes;       
		 }
	| kwattributeDeclaration
        {
		  ObjectArray* oaAttributes;
		  KWAttribute* attribute=$1;
		  KWClass* kwcClass=kwcLoadCurrentClass;

		  /* Creation d'un tableau */
		  oaAttributes = new ObjectArray;

		  /* Si attribut non valide: on ne fait rien */
		  if (attribute == NULL)
		    ; 
		  /* Si classe non valide, supression de l'attribut */
		  else if (kwcClass == NULL)
		    delete attribute;
	      /* Sinon, test de validite du nom de l'attribut */
		  else if (! kwcClass->CheckName(attribute->GetName(), kwcClass))
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Incorrect variable name (" + attribute->GetName() + ")", -1);
			delete attribute;
		  }
		  /* Test de non existence parmi les attributs */
		  else if (kwcClass->LookupAttribute(attribute->GetName()) != NULL)
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Variable name already used (" + attribute->GetName() + ")", -1);
			delete attribute;
  		  }
		  /* Test de non existence parmi les blocs */
		  else if (kwcClass->LookupAttributeBlock(attribute->GetName()) != NULL)
		  {
		    yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() + 
			": Variable name already used by a block (" + attribute->GetName() + ")", -1);
			delete attribute;
  		  }
		  /* Si OK, d'insertion */
		  else
		  {
		    kwcClass->InsertAttribute(attribute);
		    oaAttributes->Add(attribute);
		  }

		  $$ = oaAttributes;       
		 }
		;

kwclassHeader: comments rootDeclaration CLASS IDENTIFIER keyFields metaData '{'
	   {
          KWClass *kwcClass;
		  KWClass* kwcReferencedClass;

          /* Test d'existence de la classe */
          kwcClass = kwcdLoadDomain->LookupClass(*($4));

          /* Test d'existence de la classe en tant que classe referencee uniquement */
          kwcReferencedClass = cast(KWClass*, odReferencedUncreatedClasses->Lookup(*($4)));
		  assert(kwcReferencedClass == NULL or kwcClass == NULL);

          /* Erreur si la classe existe deja */
          if (kwcClass != NULL)
          {
            yyerror("Dictionary " + *($4) + " already exists");
   	        kwcClass = NULL;
          }
		  /* On utilise la classe referencee si elle existe */
		  else if (kwcReferencedClass != NULL)
		  {
		     /* Insertion dans le domaine */
		     kwcClass = kwcReferencedClass;
			 kwcdLoadDomain->InsertClass(kwcClass);

			 /* Supression de la classe referencees */
			 odReferencedUncreatedClasses->RemoveKey(kwcReferencedClass->GetName());
			 kwcReferencedClass = NULL;
		  }
 		  /* Sinon, on cree la classe et on l'enregistre */
          else
          {
		    /* Test de nom de classe */
		    if (KWClass::CheckName(*($4), NULL))
		    {
              kwcClass = new KWClass;
              kwcClass->SetName(*($4));
              kwcdLoadDomain->InsertClass(kwcClass);
		    }
		    else
		      yyerror("Incorrect dictionary name (" + *($4) + ")");
          }

		  /* Initialisation si necessaire de la classe */
		  if (kwcClass != NULL)
		  {
            /* Class Label */
            if ($1!=NULL)
              kwcClass->SetLabel(*($1));

            /* Classe racine */
            kwcClass->SetRoot($2);
            
            /* Attribut key field */
            if ($5!=NULL)
            {
              StringVector* svKeyFields;
              int i;
              
              // Transfert des champs de la cle */ 
              svKeyFields = cast(StringVector*, $5);
              kwcClass->SetKeyAttributeNumber(svKeyFields->GetSize());
              for (i = 0; i < svKeyFields->GetSize(); i++)
                kwcClass->SetKeyAttributeNameAt(i, svKeyFields->GetAt(i));
            }

			/* Meta-donnees de la classe */
			if ($6 != NULL)
			{
			    kwcClass->GetMetaData()->CopyFrom($6);
		    }
          }

          /* Liberation des tokens */
          if ($1!=NULL) delete $1;  /* Label */
          delete $4;  /* Name */
          if ($5!=NULL)  /* Key fields */
          {
              StringVector* svKeyFields;
              svKeyFields = cast(StringVector*, $5);
              delete svKeyFields;
          }
          if ($6!=NULL) 
		  delete $6; /* Key value pairs */

		  /* Memorisation dz la classe courante */
		  kwcLoadCurrentClass = kwcClass;
		  $$ = kwcClass;
	   }
	   ;

keyFields:
      '(' keyFieldList ')' comments
        {
		  /* On ignore les comemntaires */
		  if ($4 != NULL)
		    delete $4;
		  $$ = $2;
        }
	| comments
		{
		  /* On ignore les comemntaires */
		  if ($1 != NULL)
		    delete $1;
          $$ = NULL; /* pas de champ cle */
		}
    | /* NULL */
        {
          $$ = NULL; /* pas de champ cle */
        }
    ;

keyFieldList:
	  keyFieldList ',' IDENTIFIER
        {
            StringVector* svKeyFields;
            
            /* Creation d'un nouveau de champ dans le tableau de champs cles */
            svKeyFields = cast(StringVector*, $1);
            svKeyFields->Add(*$3);
		    delete $3;
			$$ = svKeyFields;
        }
    | IDENTIFIER 
        {
            StringVector* svKeyFields;
            
            /* Creation d'un tableau de champ cle, et d'un premier champ dans la cle */
            svKeyFields = new StringVector;
            svKeyFields->Add(*$1);
		    delete $1;
			$$ = svKeyFields;
        }
    ;

metaData:
	  metaData '<' SIMPLEIDENTIFIER '=' STRINGLITTERAL '>'
        {
            KWMetaData* metaData;
            
            /* Creation si necessaire d'une ensemble de paires cles valeur */
			if ($1 == NULL)
			    metaData = new KWMetaData;
			else
                metaData = cast(KWMetaData*, $1);

			/* Erreur si cle deja existante */
			if (metaData->IsKeyPresent(*$3))
			    yyerror("Duplicate key in meta-data for key " + *($3) );
			/* Insertion d'une paire avec valeur chaine de caracteres sinon */
			else
			    metaData->SetStringValueAt(*($3), *($5));
		    delete $3;
		    delete $5;
			$$ = metaData;
        }
	| metaData '<' SIMPLEIDENTIFIER '=' CONTINUOUSLITTERAL '>'
        {
            KWMetaData* metaData;
            
            /* Creation si necessaire d'une ensemble de paires cles valeur */
			if ($1 == NULL)
			    metaData = new KWMetaData;
			else
                metaData = cast(KWMetaData*, $1);

			/* Erreur si cle deja existante */
			if (metaData->IsKeyPresent(*$3))
			    yyerror("Duplicate key in meta-data for key " + *($3) );
			/* Erreur si valeur Missing */
			else if ($5 == KWContinuous::GetMissingValue())
			    yyerror("Missing value not allowed in meta-data for key " + *($3) );
			/* Insertion d'une paire avec valeur numerique sinon */
			else
			    metaData->SetDoubleValueAt(*($3), $5);
		    delete $3;
			$$ = metaData;
        }
	| metaData '<' SIMPLEIDENTIFIER '>'
        {
            KWMetaData* metaData;
            
            /* Creation si necessaire d'une ensemble de paires cles valeur */
			if ($1 == NULL)
			    metaData = new KWMetaData;
			else
                metaData = cast(KWMetaData*, $1);

			/* Erreur si cle deja existante */
			if (metaData->IsKeyPresent(*$3))
			    yyerror("Duplicate key in meta-data for key " + *($3) );
			/* Insertion d'une paire avec valeur numerique sinon */
			else
			    metaData->SetNoValueAt(*($3));
		    delete $3;
			$$ = metaData;
        }
	|  metaData '<' SIMPLEIDENTIFIER '=' IDENTIFIER '>'
        {
            KWMetaData* metaData;
            
            /* Creation si necessaire d'une ensemble de paires cles valeur */
			if ($1 == NULL)
			    metaData = new KWMetaData;
			else
                metaData = cast(KWMetaData*, $1);

			/* Erreur car la valeur n'est pas du bon type */
		    yyerror("Value (" + *($5) + ") of meta-data for key " + *($3) + " should be a string value between double quotes");
		    delete $3;
		    delete $5;
			$$ = metaData;
        }
    | /* NULL */
        {
          $$ = NULL; /* pas de paires cle valeurs */
        }
    ;



kwattributeDeclaration:
      usedDeclaration 
	  typeDeclaration 
	  refIdentifier 
	  IDENTIFIER 
	  usedDerivationRule 
	  semicolon
	  metaData
	  comments
        {
          KWAttribute *attribute;
          KWDerivationRule* rule;

          /* Creation  et initialisation d'un attribut */
          attribute = new KWAttribute;
		  attribute->SetUsed($1);
		  attribute->SetType($2);
		  
		  /* Test de coherence entre le type et le complement de type dans le cas d'un type relation */
		  if (KWType::IsRelation(attribute->GetType()))
		  {
			 if ($3 == NULL)
			    yyerrorWithLineCorrection("Variable " + *($4) + " of type " + KWType::ToString($2) + 
				": missing " +  KWType::ToString($2) + " dictionary", -1);
		  }
		  /* Test de coherence entre le type et le complement de type dans le cas d'un type Structure */
		  else if (attribute->GetType() == KWType::Structure)
		  {
			 if ($3 == NULL)
			    yyerrorWithLineCorrection("Variable " + *($4) + " of type " + KWType::ToString($2) + 
				": missing " +  KWType::ToString($2) + " dictionary", -1);
		  }
		  /* Test d'absence de complement de type dans les autres cas */
		  else
		  {
			 if ($3 != NULL)
			    yyerrorWithLineCorrection("Variable " + *($4) + " of type " + KWType::ToString($2) + 
				": erroneous (" +  *($3) + ") type complement", -1);
		  }

		  /* Classe referencee */
		  if (KWType::IsRelation(attribute->GetType()))
		  {
		    KWClass* kwcReferencedClass = NULL;

            /* Test d'existence de la classe */
            if ($3 != NULL)
              kwcReferencedClass = kwcdLoadDomain->LookupClass(*($3));

            /* Sinon, test d'existence de la classe en tant que classe referencee uniquement */
            if (kwcReferencedClass == NULL and $3 != NULL)
                kwcReferencedClass = cast(KWClass*, odReferencedUncreatedClasses->Lookup(*($3)));

            /* Si la classe n'existe pas, on essaie de la creer */
            if (kwcReferencedClass == NULL and $3 != NULL)
		    {
		      /* Test de nom de classe */
		      if (KWClass::CheckName(*($3), NULL))
		      {
                kwcReferencedClass = new KWClass;
                kwcReferencedClass->SetName(*($3));

				/* Memorisation dans le dictionnaire des classe referencees */
                odReferencedUncreatedClasses->SetAt(kwcReferencedClass->GetName(), kwcReferencedClass);
		      }
		      else
		        yyerrorWithLineCorrection("Incorrect referenced dictionary name (" + *($3) + ")", -1);
		    }

		    /* On memorise la classe referencee */
		    attribute->SetClass(kwcReferencedClass);
          }
		  /* Structure referencee */
		  else if (attribute->GetType() == KWType::Structure)
		  {
		    if ($3 != NULL)
              attribute->SetStructureName(*($3));
          }
          if ($3 != NULL)
            delete $3;

		  /* Nom de l'attribut */
		  attribute->SetName (*($4));
          delete $4; /* liberation de la valeur de IDENTIFIER */
          rule = $5;
		  attribute->SetDerivationRule(rule);

		  /* Completion eventuelle de la regle par les infos de type de l'attribut */
		  if (rule != NULL)
		  {
            // Completion specifique dans le cas de la regle de gestion des references
            if (rule->GetName() == KWDerivationRule::GetReferenceRuleName() and rule->GetOperandNumber() > 0)
            {
			  if (KWType::IsRelation(rule->GetType()) and
		          rule->GetObjectClassName() == "" and attribute->GetClass() != NULL)
		        rule->SetObjectClassName(attribute->GetClass()->GetName());
            }
            
 		    // Completion standard
 		    if (KWType::IsRelation(rule->GetType()) and
			    rule->GetObjectClassName() == "" and attribute->GetClass() != NULL)
              rule->SetObjectClassName(attribute->GetClass()->GetName());
            
            // Erreur si type renvoye par la regle different du type de l'attribut
            if (attribute->GetType() != rule->GetType())
		        yyerrorWithLineCorrection("Type of variable " + attribute->GetName() + " (" + 
                KWType::ToString(attribute->GetType()) + ") inconsistent with that returned by derivation rule " +
                attribute->GetDerivationRule()->GetName() + " (" + KWType::ToString(attribute->GetDerivationRule()->GetType()) + ")", -1);
            // Erreur dans le cas du type Structure
            else if (attribute->GetType() == KWType::Structure and attribute->GetStructureName() != rule->GetStructureName())
		        yyerrorWithLineCorrection("Type of variable " + attribute->GetName() + " (" + 
                KWType::ToString(attribute->GetType()) + "(" + attribute->GetStructureName() + ")) inconsistent with that returned by derivation rule " +
                attribute->GetDerivationRule()->GetName() + " (" + KWType::ToString(attribute->GetDerivationRule()->GetType()) + "(" + rule->GetStructureName() + "))", -1);
		  }

		  /* Meta-donnees de l'attribut */
		  if ($7 != NULL)
		  {
		    attribute->GetMetaData()->CopyFrom($7);
		    delete $7;
		  }

		  /* Commentaires */
		  if ($8 != NULL)
		  {
		    attribute->SetLabel(*($8));
		    delete $8;
		  }

		  $$ = attribute;
        }
    ;



applicationids:
      applicationids APPLICATIONID
        {
		  /* On ne garde que la premiere ligne de chaque identification d'application */
		  if ($1 == NULL)
            $$ = $2;
		  else
		  {
		    delete $2;
			$$ = $1;
		  }
        }
    | /* NULL */
        {
          $$ = NULL; /* pas d'identification d'application */
        }
    ;


comments:
      comments LABEL
        {
		  /* On ne garde que la premiere ligne de chaque commentaire */
		  if ($1 == NULL)
            $$ = $2;
		  else
		  {
		    delete $2;
			$$ = $1;
		  }
        }
    | /* NULL */
        {
          $$ = NULL; /* pas de commentaire */
        }
    ;


rootDeclaration:
      ROOT
        {
          $$ = true;
        }
    | /* NULL */
        {
          $$ = false; /* valeur par defaut */
        }
    ;


usedDeclaration:
      UNUSED
        {
          $$ = false;
        }
    | /* NULL */
        {
          $$ = true; /* valeur par defaut */
        }
    ;


typeDeclaration:
      CONTINUOUSTYPE
        {
          $$ = KWType::Continuous;
        }
    | SYMBOLTYPE
        {
          $$ = KWType::Symbol;
        }
    | DATETYPE
        {
          $$ = KWType::Date;
        }
    | TIMETYPE
        {
          $$ = KWType::Time;
        }
    | TIMESTAMPTYPE
        {
          $$ = KWType::Timestamp;
        }
    | TIMESTAMPTZTYPE
        {
          $$ = KWType::TimestampTZ;
        }
    | TEXTTYPE
        {
          $$ = KWType::Text;
        }
    | TEXTLISTTYPE
        {
          $$ = KWType::TextList;
        }
    | OBJECTTYPE
        {
          $$ = KWType::Object;
        }
    | OBJECTARRAYTYPE
        {
          $$ = KWType::ObjectArray;
        }
    | STRUCTURETYPE
        {
          $$ = KWType::Structure;
        }
    ;


refIdentifier:
	  '(' IDENTIFIER ')'
        {
		  $$ = $2;
        }
    | /* NULL */
        {
		  $$ = NULL;
        }
    ;


usedDerivationRule: '=' derivationRule
		{
		  $$ = $2;
		}
    |  referenceRule
		{
		  $$ = $1;
		}
    |  '=' derivationRule ')'
        {
		  yyerror("Too many ')'");
		  $$ = $2;
        }
    |  '(' IDENTIFIER ')'
        { 
		  ALString sTmp;
		  yyerror(sTmp + "Invalid syntax (" + *$2 + ")");
		  if ($2 != NULL)
		     delete $2;
		  $$ = NULL;
        }
    | /* NULL */
        {
		  $$ = NULL;
        }
		;

referenceRule: referenceRuleBody ']'
		{
		  $$ = $1;
		}
		;

referenceRuleBody: '[' derivationRuleOperand
		{
		  KWDerivationRule* rule;
		  KWDerivationRuleOperand* operand;

		  /* Construction d'une regle pour accueillir les specifications */
		  rule = KWDerivationRule::CloneDerivationRule(KWDerivationRule::GetReferenceRuleName());
		
		  /* Destruction des operandes */
		  rule->DeleteAllOperands();
		  
		  /* Ajout d'un premier operande: le premier champ de la cle de reference */
		  operand = $2;
		  if (operand->GetType() == KWType::Unknown)
		      operand->SetType(KWType::Symbol);
		  rule->AddOperand(operand);
		  
		  /* On retourner la regle */
		  $$ = rule;
		}
	| referenceRuleBody ',' derivationRuleOperand
		{
		  KWDerivationRule* rule = $1;
		  KWDerivationRuleOperand* operand;

		  /* Ajout d'un autre operande: un autre champ de la cle de reference */
		  operand = $3;
		  if (operand->GetType() == KWType::Unknown)
		      operand->SetType(KWType::Symbol);
		  rule->AddOperand(operand);
		  
		  /* On retourner la regle */
		  $$ = rule;
		}
	;

derivationRule: derivationRuleBody closeparenthesis
		{
		  KWDerivationRule* ruleBody = $1;
		  KWDerivationRule* rule;
		  KWDerivationRuleOperand* ruleBodyOperand;
		  KWDerivationRuleOperand* ruleOperand;
		  int i;
		  boolean bRuleOk;
		  ALString sTmp;
		  
		  /* Recherche de la regle de reference */
		  check(ruleBody);
		  rule = KWDerivationRule::CloneDerivationRule(ruleBody->GetName());
		  
		  /* Erreur si regle inexistante */
		  if (rule == NULL)
		  {
		    yyerror("Unknown derivation rule '" + ruleBody->GetName() + "'");
		  }
		  /* Erreur si regle predefinie de Reference */
		  else if (rule->GetName() == KWDerivationRule::GetReferenceRuleName())
		  {
		    yyerror("Unknown derivation rule '" + ruleBody->GetName() + "'");
			delete rule;
			rule = NULL;
		  }
		  /* Sinon, test du nombre d'arguments */
		  else if ((rule->GetVariableOperandNumber() and 
					ruleBody->GetOperandNumber() < rule->GetOperandNumber()-1) or
					(not rule->GetVariableOperandNumber() and 
					ruleBody->GetOperandNumber() != rule->GetOperandNumber()))

		  {
		    yyerror(sTmp + "Number of operands (" +
              IntToString(ruleBody->GetOperandNumber()) +
              ") inconsistent with that of rule " + rule->GetName() + " (" +
              IntToString(rule->GetOperandNumber()) + ")");
			delete rule;
			rule = NULL;
		  }
	      /* Verification et transfert des operandes */
          else
          {
		    /* Dans le cas d'un nombre variable d'operandes, on commence par rajouter */
			/* eventuellement des operandes en fin de regle pour preparer l'instanciation */
			if (ruleBody->GetOperandNumber() > rule->GetOperandNumber())
			{
			   assert(rule->GetVariableOperandNumber());
			   while (rule->GetOperandNumber() < ruleBody->GetOperandNumber())
			      rule->AddOperand(rule->GetOperandAt(rule->GetOperandNumber()-1)->Clone());
			}

		    /* Dans le cas d'un nombre variable d'operandes, on supprime eventuellement */
			/* le dernier operande, qui n'est pas obligatoire */
			if (ruleBody->GetOperandNumber() < rule->GetOperandNumber())
			{
			   assert(rule->GetVariableOperandNumber());
			   assert(ruleBody->GetOperandNumber() == rule->GetOperandNumber()-1);
			   rule->DeleteAllVariableOperands();
			}
			assert(ruleBody->GetOperandNumber() == rule->GetOperandNumber());

			/* Transfert des operandes */
		    bRuleOk = true;
            for (i = 0; i < rule->GetOperandNumber(); i++)
			{
			  /* acces aux operandes */
			  ruleOperand = rule->GetOperandAt(i);
			  ruleBodyOperand = ruleBody->GetOperandAt(i);

			  /* Transfert d'informations de la regle de reference vers la regle a verifier */
			  if (ruleBodyOperand->GetOrigin() != KWDerivationRuleOperand::OriginConstant)
			  {
			    ruleBodyOperand->SetType(ruleOperand->GetType());
				if (KWType::IsRelation(ruleOperand->GetType()))
					ruleBodyOperand->SetObjectClassName(ruleOperand->GetObjectClassName());
			  }
			  if (ruleOperand->GetType() == KWType::Structure)
			  {
			      ruleBodyOperand->SetType(KWType::Structure);
			      ruleBodyOperand->SetStructureName(ruleOperand->GetStructureName());
			  }

			  /* Test si operande candidate valide */
			  if (not ruleBodyOperand->CheckDefinition())
			  {
			    bRuleOk = false;
				yyerror(sTmp + "Incorrect operand " + IntToString(1+i) + " for rule " + rule->GetName());
			  }
			  /* Test de compatibilite avec la regle enregistree, sauf si regle avec operande de type indetermine */
			  else if (ruleOperand->GetType() != KWType::Unknown and not ruleBodyOperand->CheckFamily(ruleOperand))
			  {
			    bRuleOk = false;
				yyerror(sTmp + "Operand " + IntToString(1+i) + " inconsistent with that of rule " + rule->GetName());
				break;
			  }
			  /* Transfert de l'origine de l'operande */
			  else
			  {
			    /* Transfert du niveau de scope */
				ruleOperand->SetScopeLevel(ruleBodyOperand->GetScopeLevel());

			    /* Transfert d'une valeur constante */
			    ruleOperand->SetOrigin(ruleBodyOperand->GetOrigin());
				if (ruleOperand->GetOrigin() == KWDerivationRuleOperand::OriginConstant)
				{
				   ruleOperand->SetType(ruleBodyOperand->GetType());
				   ruleOperand->SetStringConstant(ruleBodyOperand->GetStringConstant());
				}
				/* Transfert d'un attribut */
				else if (ruleOperand->GetOrigin() == KWDerivationRuleOperand::OriginAttribute)
				   ruleOperand->SetDataItemName(ruleBodyOperand->GetDataItemName());
				else
				/* Transfert d'une regle */
				{
				  // Transfert de la regle */
				  if (ruleOperand->GetDerivationRule() != NULL)
				  {
				    assert(ruleBodyOperand->GetDerivationRule() != NULL);
				    delete ruleOperand->GetDerivationRule();
				  }
				  ruleOperand->SetDerivationRule(ruleBodyOperand->GetDerivationRule());
				  
				  /* Transfert des infos portees par la regle de derivation */
				  if (ruleOperand->GetDerivationRule() != NULL)
				  {
					ruleOperand->SetType(ruleOperand->GetDerivationRule()->GetType());
					if (KWType::IsRelation(ruleOperand->GetType()))
						ruleOperand->SetObjectClassName(ruleOperand->GetDerivationRule()->GetObjectClassName());
			  	    if (ruleOperand->GetType() == KWType::Structure)
						ruleOperand->SetStructureName(ruleOperand->GetDerivationRule()->GetStructureName());
				  }
	  
				  /* Dereferencement de la regle de derivation depuis l'operande de travail */
				  ruleBodyOperand->SetDerivationRule(NULL);
				}
			  }
            }

			/* Verification de la definition de la regle */
			if (bRuleOk and not rule->CheckDefinition())
			{
			  bRuleOk = false;
			  yyerror(sTmp + "Derivation rule "  + rule->GetName() + " incorrectly specified");
			}

			/* Test si erreur dans le transfert des operandes */
			if (not bRuleOk)
			{
			  delete rule;
			  rule = NULL;
			}
			/* Sinon, on tente de compresser la regle */
			else
			{
				if (rule->IsStructureRule())
				{
 				  KWDRStructureRule* structureRule;

				  /* Acces a la regle de structure, transformation au format structure et nettoyage memoire */
				  /* Cette optimisation memoire des regles structure est critique dans le cas de dictionnaires */
				  /* de tres grande taille. Sinon, des millions d'operandes de regles sont potentiellement crees, */
				  /* puis lors de la compilation des dictionnaire, l'essentiel de la memoire liberee laisse des trous */
				  /* dans les segments de la heap, qui ne peuvent etre rendus au systeme */
  			      assert(rule->CheckDefinition());
				  structureRule = cast(KWDRStructureRule*, rule);
				  structureRule->BuildStructureFromBase(rule);
				  structureRule->CleanCompiledBaseInterface();
				}
			}
		  }
 		  delete ruleBody;

		  $$ = rule;
		}
	;


derivationRuleBody: derivationRuleBegin
		{
		  $$ = $1;
		}
	| derivationRuleHeader
		{
		  $$ = $1;
		}
	;


derivationRuleHeader: IDENTIFIER openparenthesis
		{
		  KWDerivationRule* rule;

		  /* Construction d'une regle pour accueillir les specification */
		  rule = new KWDerivationRule;
		  rule->SetName(*($1));
		  delete $1;
		  $$ = rule;
		}
		;


derivationRuleBegin: derivationRuleHeader derivationRuleOperand
		{
		  KWDerivationRule* rule = $1;
		  KWDerivationRuleOperand* operand = $2;
		  
		  check(rule);
		  assert(rule->GetOperandNumber() == 0);
		  check(operand);
		  rule->AddOperand(operand);
		  $$ = rule;
		}
	| derivationRuleBegin ',' derivationRuleOperand
		{
		  KWDerivationRule* rule = $1;
		  KWDerivationRuleOperand* operand = $3;
		  
		  check(rule);
		  assert(rule->GetOperandNumber() > 0);
		  check(operand);
		  rule->AddOperand(operand);
		  $$ = rule;
		}
		;


derivationRuleOperand: IDENTIFIER 
		{
		  KWDerivationRuleOperand* operand;
		  operand = new KWDerivationRuleOperand;
		  operand->SetOrigin(KWDerivationRuleOperand::OriginAttribute);
		  operand->SetDataItemName(*($1));
		  delete $1;
		  $$ = operand;
		}
	| CONTINUOUSLITTERAL
		{
		  KWDerivationRuleOperand* operand;
		  operand = new KWDerivationRuleOperand;
		  operand->SetType(KWType::Continuous);
		  operand->SetOrigin(KWDerivationRuleOperand::OriginConstant);
		  operand->SetContinuousConstant($1);
		  $$ = operand;
		}
	| bigstring
		{
		  KWDerivationRuleOperand* operand;
		  operand = new KWDerivationRuleOperand;
		  operand->SetType(KWType::Symbol);
		  operand->SetOrigin(KWDerivationRuleOperand::OriginConstant);
		  operand->SetSymbolConstant(Symbol(*($1)));
		  delete $1;
		  $$ = operand;
		}
	| derivationRule
		{
		  KWDerivationRuleOperand* operand;
		  operand = new KWDerivationRuleOperand;
		  operand->SetOrigin(KWDerivationRuleOperand::OriginRule);
		  operand->SetDerivationRule($1);
		  if (operand->GetDerivationRule() != NULL)
		      operand->SetType(operand->GetDerivationRule()->GetType());
		  $$ = operand;
		}
	| '.' derivationRuleOperand
		{
		  KWDerivationRuleOperand* operand;
		  operand = $2;
		  operand->SetScopeLevel(operand->GetScopeLevel()+1);
		  $$ = operand;
		}
		;


bigstring:
	  bigstring '+' STRINGLITTERAL
        {
		  /* Concatenation des deux chaines */
          $$ = new ALString (*$1 + *$3);

		  /* Destruction des ancienne chaines */
		  delete $1;
		  delete $3;
        }
	|	STRINGLITTERAL
		{
		  $$ = $1;
		}
	;

semicolon:
      ';'
   | ';' ';'
        {
          yyerror("There is one superfluous ';'");
        }
   | ';' ';' ';'
        {
          yyerror("Too many ';'");
        }
   | /* NULL */
        {
          yyerror("Missing ';'");
        }
    ;

openparenthesis:
      '('
   | '(' '('
        {
          yyerror("There is one superfluous '('");
        }
   | '(' '(' '('
        {
          yyerror("Too many '('");
        }
   | /* NULL */
        {
		  /* ERRORMGT */
		  /* Attention: supprimer cette instruction en cas d'evolution du parser */
		  /* Cette instruction est la pour aider au diagnostique des erreurs */
		  /* de parenthesage: elle est utile dans ce cas, mais genere (avec  */
		  /* sa consoeur 3 shift/reduce conflicts et 12 reduce conflicts     */
          yyerror("Missing '('");
        }
    ;


closeparenthesis:
	  ')'
   | /* NULL */
        {
		  /* ERRORMGT */
		  /* Attention: supprimer cette instruction en cas d'evolution du parser */
		  /* Cette instruction est la pour aider au diagnostique des erreurs */
		  /* de parenthesage: elle est utile dans ce cas, mais genere (avec  */
		  /* sa consoeur 3 shift/reduce conflicts et 12 reduce conflicts     */
          yyerror("Missing ')'");
        }
	;


%%


#include "KWCLex.inc"


/* default yywrap that tells yylex to return 0 */
int yywrap()
{
  return 1;
}


/* default yyerror for YACC and LEX */
void yyerror(char const *fmt)
{
   yyerrorWithLineCorrection(fmt, 0);
}

/* Variante avec une correction du numero de ligne */
void yyerrorWithLineCorrection(char const *fmt, int nDeltaLineNumber)
{
  char sErrorLine[20];
  ALString sLabel;
  int nLineNumber;

  nFileParsingErrorNumber++;
  nLineNumber = yylineno+nDeltaLineNumber;
  if (nLineNumber <= 0)
    nLineNumber = 1;
  snprintf(sErrorLine, sizeof(sErrorLine), "Line %d", nLineNumber);
  sLabel = fmt;
  Global::AddError("Read dictionary file",
                    sErrorLine,
                    sLabel);
}


int yyparse();


/* Implementation de la methode de lecture de fichier de KWClassDomain */
boolean KWClassDomain::ReadFile(const ALString& sFileName)
{
  boolean bOk = true;
  FILE* fFile;
  ObjectDictionary odInitialClasses;
  ObjectArray oaNewClasses;
  ObjectArray oaReferencedUncreatedClasses;
  int i;
  KWClass* kwcClass;
  ALString sLocalFileName;

  /* Affichage de stats memoire si log memoire actif */
  MemoryStatsManager::AddLog(GetClassLabel() + " " + sFileName + " ReadFile Begin");

  /* Initialisation du domaine de classe a utiliser pour le Load */
  assert(kwcdLoadDomain == NULL);
  kwcdLoadDomain = this;

  /* Initialisation de la classe courante a utiliser pour le Load */
  assert(kwcLoadCurrentClass == NULL);
  kwcLoadCurrentClass = NULL;

  /* Creation du dictionnaire des classes referencees non crees */
  assert(odReferencedUncreatedClasses == NULL);
  odReferencedUncreatedClasses = new ObjectDictionary;

  /* Erreur si pas de nom de fichier */
  fFile = NULL;
  if (sFileName == "")
  {
     AddError("Missing file name");
	 bOk = false;
  }
  /* Sinon, ouverture du fichier */
  else
  { 
		// Copie depuis HDFS si necessaire
		bOk = PLRemoteFileService::BuildInputWorkingFile(sFileName, sLocalFileName);
		if (bOk)
			bOk = FileService::OpenInputBinaryFile(sLocalFileName, fFile);
  }

  /* On continue si fichier ouvert correctement */
  if (bOk)
  {
    assert(fFile != NULL);

    /* Memorisation de toutes les classes initiales */
    kwcdLoadDomain->ExportClassDictionary(&odInitialClasses);

	/* Activation du nombre max d'erreurs a afficher */
	nFileParsingErrorNumber = 0;
	Global::ActivateErrorFlowControl();

    /* Positionnement du fichier a parser par la variable yyin de LEX */
    yylineno = 1;
    yyrestart(fFile);
    
	/* Parsing */
    yyparse();

	/* Cleaning lexer */
	yylex_destroy();

    /* Fermeture du fichier */
	FileService::CloseInputBinaryFile(sLocalFileName, fFile);
	
	/* Si HDFS on supprime la copie locale */
	PLRemoteFileService::CleanInputWorkingFile(sFileName, sLocalFileName);

	/* Completion des informations de type au niveau du domaine */
	if (nFileParsingErrorNumber == 0)
	  kwcdLoadDomain->CompleteTypeInfo();

	/* Lecture des informations sur les attributs utilises mais non charges en memoire */
	if (nFileParsingErrorNumber == 0)
	{
		for (i = 0; i < kwcdLoadDomain->GetClassNumber(); i++)
		{
			kwcClass = kwcdLoadDomain->GetClassAt(i);
			kwcClass->ReadNotLoadedMetaData();
		}
	}

    /* Messages d'erreur pour les classes referencees non crees */
	if (nFileParsingErrorNumber > 0 or odReferencedUncreatedClasses->GetCount() > 0)
	{
	  odReferencedUncreatedClasses->ExportObjectArray(&oaReferencedUncreatedClasses);
	  for (i = 0; i < oaReferencedUncreatedClasses.GetSize(); i++)
	  {
	    kwcClass = cast(KWClass*, oaReferencedUncreatedClasses.GetAt(i));
        AddError("Dictionary " + kwcClass->GetName() + " used, but not declared");
	  }
	}

	/* Desactivation du nombre max d'erreurs a afficher */
	Global::DesactivateErrorFlowControl();

    /* Destruction des classes crees si au moins une erreur de parsing detectee */
	/* ou au moins une classe referencee non cree                               */
	if (nFileParsingErrorNumber > 0 or odReferencedUncreatedClasses->GetCount() > 0)
    {
	  /* En cas d'erreur, ajout d'une ligne blanche pour separer des autres logs */
      AddError("Errors detected during parsing " + sFileName + ": read operation cancelled");
	  AddSimpleMessage("");
	  bOk = false;

 	  /* Recherche des nouvelles classes crees */
	  for (i = 0; i < kwcdLoadDomain->GetClassNumber(); i++)
	  {
	    kwcClass = kwcdLoadDomain->GetClassAt(i);
	    if (odInitialClasses.Lookup(kwcClass->GetName()) == NULL)
	      oaNewClasses.Add(kwcClass);
	  }

	  /* Destruction des classes nouvellement crees */
	  for (i = 0; i < oaNewClasses.GetSize(); i++)
	  {
	    kwcClass = cast(KWClass*, oaNewClasses.GetAt(i));
	    kwcdLoadDomain->DeleteClass(kwcClass->GetName());
	  }

	  /* Destruction des classes referencees non crees */
      odReferencedUncreatedClasses->DeleteAll();
	}
	nFileParsingErrorNumber = 0;
  }

  /* Nettoyage */
  kwcdLoadDomain = NULL;
  kwcLoadCurrentClass = NULL;
  delete odReferencedUncreatedClasses;
  odReferencedUncreatedClasses = NULL;

  /* Affichage de stats memoire si log memoire actif */
  MemoryStatsManager::AddLog(GetClassLabel() + " " + sFileName + " ReadFile End");

  return bOk;
}
