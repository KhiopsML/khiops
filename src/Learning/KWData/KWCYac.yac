%
{

	/* ATTENTION: les regles openparenthesis et closeparenthesis generent             */
	/* 3 shift/reduce conflicts et 15 reduce/reduce conflicts                         */
	/* La regle kwclassBegin genere 1 reduce/reduce conflict supplementaire           */
	/* Attention: modifier ces regles en cas d'evolution du parser                    */
	/* Ces regles ne sont utiles que pour le diagnostique des erreurs de parenthesage */
	/* ou de rattrapage sur declaration d'attribut erronee                            */
	/* Ces regles sont reperables par le mot cle ERRORMGT                             */

#include "KWClassDomain.h"
#include "KWClass.h"
#include "KWContinuous.h"
#include "KWDerivationRule.h"
#include "KWStructureRule.h"
#include "KWMetaData.h"

	/* Declaration du lexer utilise */
	void yyerror(char const* fmt);
	void yyerrorWithLineCorrection(char const* fmt, int nDeltaLineNumber);
	int yylex();

/* Work around a bug in the relation between bison and GCC 3.x: */
#if defined(__GNUC__) && 3 <= __GNUC__
#define __attribute__(arglist)
#endif

	/* Domaine de classe courant a utiliser pendant la lecture d'un fichier. */
	/* Ce domaine est positionner par la methode Load de KWClassDomain       */
	static KWClassDomain* kwcdLoadDomain = NULL;

	/* Classe courante a utiliser pendant la lecture d'un fichier.     */
	/* Ce domaine est positionner par la methode Load de KWClassDomain */
	static KWClass* kwcLoadCurrentClass = NULL;

	/* Dictionnaire des classes referencees creees a la volee lorsqu'elles sont      */
	/* utilisees, mais non crees.                                                    */
	/* On rajoute les classes referencees non crees, et on retire les classes crees. */
	static ObjectDictionary* odReferencedUncreatedClasses = NULL;

	/* Nombre total d'erreurs de parsing */
	static int nFileParsingErrorNumber = 0;

#define YY_STATIC

	/* Debugging YAC */

	/*
	#define YYDEBUG 1
	extern char   *yyptok(int i);
	*/

	%
}

% union
{
	Continuous cValue;
	ALString* sValue;
	boolean bValue;
	StringVector* svValue;
	KWDerivationRule* kwdrValue;
	KWDerivationRuleOperand* kwdroValue;
	KWClass* kwcValue;
	KWAttribute* kwaValue;
	ObjectArray* oaAttributes;
	KWMetaData* kwmdMetaData;
	int nValue;
};

% token<sValue> BASICIDENTIFIER % token<sValue> EXTENDEDIDENTIFIER % token<cValue> CONTINUOUSLITTERAL % token<sValue> STRINGLITTERAL % token<sValue> LABEL % token<sValue> APPLICATIONID % token CLASS % token CONTINUOUSTYPE % token SYMBOLTYPE % token OBJECTTYPE % token OBJECTARRAYTYPE % token ROOT % token UNUSED % token DATETYPE % token TIMETYPE % token TIMESTAMPTYPE % token STRUCTURETYPE

    % type<nValue> CLASS % type<nValue> CONTINUOUSTYPE % type<nValue> SYMBOLTYPE % type<nValue> OBJECTTYPE % type<nValue> OBJECTARRAYTYPE % type<sValue> IDENTIFIER % type<sValue> SIMPLEIDENTIFIER % type<sValue> comments % type<sValue> applicationids % type<sValue> bigstring % type<sValue> refIdentifier % type<bValue> rootDeclaration % type<bValue> usedDeclaration % type<nValue> typeDeclaration % type<kwcValue> kwclassHeader % type<kwcValue> kwclassBegin % type<kwaValue> kwattributeDeclaration % type<oaAttributes> oaAttributeArrayDeclaration % type<kwdrValue> usedDerivationRule % type<kwdrValue> referenceRule % type<kwdrValue> referenceRuleBody % type<kwdrValue> derivationRule % type<kwdrValue> derivationRuleBody % type<kwdrValue> derivationRuleHeader % type<kwdrValue> derivationRuleBegin % type<kwdroValue> derivationRuleOperand % type<svValue> keyFields % type<svValue> keyFieldList % type<kwmdMetaData> metaData

    /* Parametrage du destructeur a appeler en cas d'erreur, sauf pour les KWClass <kwcValue> qui sont integree dans des KWClassDomain */
    % destructor
{
	if ($$ != NULL)
		delete $$;
	$$ = NULL;
}
<sValue><svValue><kwdrValue><kwdroValue><oaAttributes><kwmdMetaData><kwaValue>

    % start kwclassFile

    % %

    IDENTIFIER : SIMPLEIDENTIFIER
{
	$$ = $1;
}
| EXTENDEDIDENTIFIER
{
	$$ = $1;
};

SIMPLEIDENTIFIER : BASICIDENTIFIER
{
	$$ = $1;
}
| CLASS
{
	$$ = new ALString("Dictionary");
}
| CONTINUOUSTYPE
{
	$$ = new ALString("Numerical");
}
| SYMBOLTYPE
{
	$$ = new ALString("Categorical");
}
| OBJECTTYPE
{
	$$ = new ALString("Entity");
}
| OBJECTARRAYTYPE
{
	$$ = new ALString("Table");
}
| ROOT
{
	$$ = new ALString("Root");
}
| UNUSED
{
	$$ = new ALString("Unused");
}
| DATETYPE
{
	$$ = new ALString("Date");
}
| TIMETYPE
{
	$$ = new ALString("Time");
}
| TIMESTAMPTYPE
{
	$$ = new ALString("Timestamp");
}
| STRUCTURETYPE
{
	$$ = new ALString("Structure");
};

kwclassFile : applicationids kwclasses comments
{
	/* On ignore l'identification d'application */
	if ($1 != NULL)
		delete $1;

	/* On ignore les commentaires en fin de fichier */
	if ($3 != NULL)
		delete $3;
};

kwclasses : kwclasses kwclass | kwclasses error
{
	yyerror("Error outside the definition of a dictionary");
	YYABORT;
}
| /* NULL */
    ;

kwclass : kwclassBegin '}' semicolon
{
	/* La completion des informations de type (CompleteTypeInfo) est centralisee */
	/* au niveau du domaine en fin de parsing */

	/* Reinitialisation de la classe courante */
	kwcLoadCurrentClass = NULL;
};

kwclassBegin : kwclassHeader comments
{
	/* On ignore les premiers comemntaires */
	if ($2 != NULL)
		delete $2;
	assert(kwcLoadCurrentClass == $1);
	$$ = $1;
}
| kwclassBegin kwattributeDeclaration
{
	KWClass* kwcClass = $1;
	KWAttribute* attribute = $2;
	assert(kwcLoadCurrentClass == $1);
	boolean bOk;

	/* Si attribut non valide: on ne fait rien */
	if (attribute == NULL)
		;
	/* Si classe non valide, supression de l'attribut */
	else if (kwcClass == NULL)
		delete attribute;
	/* Sinon, test de validite du nom de l'attribut */
	else if (!kwcClass->CheckName(attribute->GetName(), kwcClass))
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Incorrect variable name",
					  -1);
		delete attribute;
	}
	/* Test de non existence parmi les attributs */
	else if (kwcClass->LookupAttribute(attribute->GetName()) != NULL)
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Variable name already used (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Test de non existence parmi les blocs */
	else if (kwcClass->LookupAttributeBlock(attribute->GetName()) != NULL)
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Variable name already used by a block (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Si OK, d'insertion */
	else
	{
		bOk = kwcClass->InsertAttribute(attribute);
		assert(bOk);
	}

	$$ = kwcClass;
}
| kwclassBegin '{' comments oaAttributeArrayDeclaration '}' IDENTIFIER usedDerivationRule semicolon metaData comments
{
	KWClass* kwcClass = $1;
	KWAttributeBlock* attributeBlock;
	ObjectArray* oaAttributes = $4;
	ALString sBlockName;
	KWAttribute* firstAttribute;
	KWAttribute* lastAttribute;
	KWDerivationRule* rule = $7;
	assert(kwcLoadCurrentClass == $1);
	check(oaAttributes);

	/* On ignore les premiers comemntaires */
	if ($3 != NULL)
		delete $3;

	/* Nom du bloc */
	if ($6 != NULL)
		sBlockName = *($6);

	/* Cas d'un bloc avec au moins un attribut valide */
	if (oaAttributes->GetSize() > 0)
	{
		/* Test de validite du nom de l'attribut */
		if (!kwcClass->CheckName(sBlockName, kwcClass))
		{
			yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
						      ": Incorrect sparse variable block name (" + sBlockName + ")",
						  -1);
		}
		/* Test de non existence parmi les attributs */
		else if (kwcClass->LookupAttribute(sBlockName) != NULL)
		{
			yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
						      ": Sparse variable block name already used by a variable (" + sBlockName + ")",
						  -1);
		}
		/* Test de non existence parmi les blocs */
		else if (kwcClass->LookupAttributeBlock(sBlockName) != NULL)
		{
			yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
						      ": Sparse variable block name already used by a block (" + sBlockName + ")",
						  -1);
		}
		/* Creation du bloc dans la classe */
		else
		{
			/* Creation du bloc */
			firstAttribute = cast(KWAttribute*, oaAttributes->GetAt(0));
			lastAttribute = cast(KWAttribute*, oaAttributes->GetAt(oaAttributes->GetSize() - 1));
			attributeBlock = kwcClass->CreateAttributeBlock(sBlockName, firstAttribute, lastAttribute);

			/* Parametrage du bloc */
			attributeBlock->SetDerivationRule(rule);
			if ($9 != NULL)
				attributeBlock->GetMetaData()->CopyFrom($9);
			if ($10 != NULL)
				attributeBlock->SetLabel(*($10));

			/* On marque la rule a NULL pour indiquer qu'elle est utilisee */
			rule = NULL;
		}
	}

	/* Destruction de l'eventuelle regle si non utilisee */
	if (rule != NULL)
		delete rule;

	/* Tous les attributs du tableau ont deja ete inseres dans la classe */
	// On se contente de detruire le tableau */
	delete oaAttributes;

	/* Nettoyage */
	if ($6 != NULL)
		delete $6;
	if ($9 != NULL)
		delete $9;
	if ($10 != NULL)
		delete $10;

	$$ = kwcClass;
}
| kwclassBegin '{' comments '}' IDENTIFIER usedDerivationRule semicolon metaData comments
{
	KWClass* kwcClass = $1;

	/* Message d'erreur */
	yyerror("Empty sparse variable block not allowed");

	/* Nettoyage */
	if ($3 != NULL)
		delete $3;
	delete $5;
	if ($6 != NULL)
		delete $6;
	if ($8 != NULL)
		delete $8;
	if ($9 != NULL)
		delete $9;
	$$ = kwcClass;
}
| kwclassBegin error
{
	/* ERRORMGT */
	/* Attention: cette regle qui permet une gestion des erreurs amelioree */
	/* genere un conflit reduce/reduce */
	kwcLoadCurrentClass = NULL;
	YYABORT;
};

oaAttributeArrayDeclaration : oaAttributeArrayDeclaration kwattributeDeclaration
{
	ObjectArray* oaAttributes = $1;
	KWAttribute* attribute = $2;
	KWClass* kwcClass = kwcLoadCurrentClass;
	boolean bOk;
	check(oaAttributes);

	/* Si attribut non valide: on ne fait rien */
	if (attribute == NULL)
		;
	/* Si classe non valide, supression de l'attribut */
	else if (kwcClass == NULL)
		delete attribute;
	/* Sinon, test de validite du nom de l'attribut */
	else if (!kwcClass->CheckName(attribute->GetName(), kwcClass))
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Incorrect variable name (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Test de non existence parmi les attributs */
	else if (kwcClass->LookupAttribute(attribute->GetName()) != NULL)
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Variable name already used (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Test de non existence parmi les blocs */
	else if (kwcClass->LookupAttributeBlock(attribute->GetName()) != NULL)
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Variable name already used by a block (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Si OK, d'insertion */
	else
	{
		bOk = kwcClass->InsertAttribute(attribute);
		oaAttributes->Add(attribute);
		assert(bOk);
	}

	$$ = oaAttributes;
}
| kwattributeDeclaration
{
	ObjectArray* oaAttributes;
	KWAttribute* attribute = $1;
	KWClass* kwcClass = kwcLoadCurrentClass;
	boolean bOk;

	/* Creation d'un tableau */
	oaAttributes = new ObjectArray;

	/* Si attribut non valide: on ne fait rien */
	if (attribute == NULL)
		;
	/* Si classe non valide, supression de l'attribut */
	else if (kwcClass == NULL)
		delete attribute;
	/* Sinon, test de validite du nom de l'attribut */
	else if (!kwcClass->CheckName(attribute->GetName(), kwcClass))
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Incorrect variable name (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Test de non existence parmi les attributs */
	else if (kwcClass->LookupAttribute(attribute->GetName()) != NULL)
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Variable name already used (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Test de non existence parmi les blocs */
	else if (kwcClass->LookupAttributeBlock(attribute->GetName()) != NULL)
	{
		yyerrorWithLineCorrection("Dictionary " + kwcClass->GetName() +
					      ": Variable name already used by a block (" + attribute->GetName() + ")",
					  -1);
		delete attribute;
	}
	/* Si OK, d'insertion */
	else
	{
		bOk = kwcClass->InsertAttribute(attribute);
		oaAttributes->Add(attribute);
		assert(bOk);
	}

	$$ = oaAttributes;
};

kwclassHeader : comments rootDeclaration CLASS IDENTIFIER keyFields metaData '{'
{
	KWClass* kwcClass;
	KWClass* kwcReferencedClass;

	/* Test d'existence de la classe */
	kwcClass = kwcdLoadDomain->LookupClass(*($4));

	/* Test d'existence de la classe en tant que classe referencee uniquement */
	kwcReferencedClass = cast(KWClass*, odReferencedUncreatedClasses->Lookup(*($4)));
	assert(kwcReferencedClass == NULL or kwcClass == NULL);

	/* Erreur si la classe existe deja */
	if (kwcClass != NULL)
	{
		yyerror("Dictionary " + *($4) + " already exists");
		kwcClass = NULL;
	}
	/* On utilise la classe referencee si elle existe */
	else if (kwcReferencedClass != NULL)
	{
		/* Insertion dans le domaine */
		kwcClass = kwcReferencedClass;
		kwcdLoadDomain->InsertClass(kwcClass);

		/* Supression de la classe referencees */
		odReferencedUncreatedClasses->RemoveKey(kwcReferencedClass->GetName());
		kwcReferencedClass = NULL;
	}
	/* Sinon, on cree la classe et on l'enregistre */
	else
	{
		/* Test de nom de classe */
		if (KWClass::CheckName(*($4), NULL))
		{
			kwcClass = new KWClass;
			kwcClass->SetName(*($4));
			kwcdLoadDomain->InsertClass(kwcClass);
		}
		else
			yyerror("Incorrect dictionary name (" + *($4) + ")");
	}

	/* Initialisation si necessaire de la classe */
	if (kwcClass != NULL)
	{
		/* Class Label */
		if ($1 != NULL)
			kwcClass->SetLabel(*($1));

		/* Classe racine */
		kwcClass->SetRoot($2);

		/* Attribut key field */
		if ($5 != NULL)
		{
			StringVector* svKeyFields;
			int i;

			// Transfert des champs de la cle */
			svKeyFields = cast(StringVector*, $5);
			kwcClass->SetKeyAttributeNumber(svKeyFields->GetSize());
			for (i = 0; i < svKeyFields->GetSize(); i++)
				kwcClass->SetKeyAttributeNameAt(i, svKeyFields->GetAt(i));
		}

		/* Meta-donnees de la classe */
		if ($6 != NULL)
		{
			kwcClass->GetMetaData()->CopyFrom($6);
		}
	}

	/* Liberation des tokens */
	if ($1 != NULL)
		delete $1; /* Label */
	delete $4;         /* Name */
	if ($5 != NULL)    /* Key fields */
	{
		StringVector* svKeyFields;
		svKeyFields = cast(StringVector*, $5);
		delete svKeyFields;
	}
	if ($6 != NULL)
		delete $6; /* Key value pairs */

	/* Memorisation dz la classe courante */
	kwcLoadCurrentClass = kwcClass;
	$$ = kwcClass;
};

keyFields : '(' keyFieldList ')' comments
{
	/* On ignore les comemntaires */
	if ($4 != NULL)
		delete $4;
	$$ = $2;
}
| comments
{
	/* On ignore les comemntaires */
	if ($1 != NULL)
		delete $1;
	$$ = NULL; /* pas de champ cle */
}
| /* NULL */
{
	$$ = NULL; /* pas de champ cle */
};

keyFieldList : keyFieldList ',' IDENTIFIER
{
	StringVector* svKeyFields;

	/* Creation d'un nouveau de champ dans le tableau de champs cles */
	svKeyFields = cast(StringVector*, $1);
	svKeyFields->Add(*$3);
	delete $3;
	$$ = svKeyFields;
}
| IDENTIFIER
{
	StringVector* svKeyFields;

	/* Creation d'un tableau de champ cle, et d'un premier champ dans la cle */
	svKeyFields = new StringVector;
	svKeyFields->Add(*$1);
	delete $1;
	$$ = svKeyFields;
};

metaData : metaData '<' SIMPLEIDENTIFIER '=' STRINGLITTERAL '>'
{
	KWMetaData* metaData;

	/* Creation si necessaire d'une ensemble de paires cles valeur */
	if ($1 == NULL)
		metaData = new KWMetaData;
	else
		metaData = cast(KWMetaData*, $1);

	/* Erreur si cle deja existante */
	if (metaData->IsKeyPresent(*$3))
		yyerror("Duplicate key in meta-data for key " + *($3));
	/* Insertion d'une paire avec valeur chaine de caracteres sinon */
	else
		metaData->SetStringValueAt(*($3), *($5));
	delete $3;
	delete $5;
	$$ = metaData;
}
| metaData '<' SIMPLEIDENTIFIER '=' CONTINUOUSLITTERAL '>'
{
	KWMetaData* metaData;

	/* Creation si necessaire d'une ensemble de paires cles valeur */
	if ($1 == NULL)
		metaData = new KWMetaData;
	else
		metaData = cast(KWMetaData*, $1);

	/* Erreur si cle deja existante */
	if (metaData->IsKeyPresent(*$3))
		yyerror("Duplicate key in meta-data for key " + *($3));
	/* Insertion d'une paire avec valeur numerique sinon */
	else
		metaData->SetDoubleValueAt(*($3), $5);
	delete $3;
	$$ = metaData;
}
| metaData '<' SIMPLEIDENTIFIER '>'
{
	KWMetaData* metaData;

	/* Creation si necessaire d'une ensemble de paires cles valeur */
	if ($1 == NULL)
		metaData = new KWMetaData;
	else
		metaData = cast(KWMetaData*, $1);

	/* Erreur si cle deja existante */
	if (metaData->IsKeyPresent(*$3))
		yyerror("Duplicate key in meta-data for key " + *($3));
	/* Insertion d'une paire avec valeur numerique sinon */
	else
		metaData->SetNoValueAt(*($3));
	delete $3;
	$$ = metaData;
}
| metaData '<' SIMPLEIDENTIFIER '=' IDENTIFIER '>'
{
	KWMetaData* metaData;

	/* Creation si necessaire d'une ensemble de paires cles valeur */
	if ($1 == NULL)
		metaData = new KWMetaData;
	else
		metaData = cast(KWMetaData*, $1);

	/* Erreur car la valeur n'est pas du bon type */
	yyerror("Value (" + *($5) + ") of meta-data for key " + *($3) + " should be a string value between double quotes");
	delete $3;
	delete $5;
	$$ = metaData;
}
| /* NULL */
{
	$$ = NULL; /* pas de paires cle valeurs */
};

kwattributeDeclaration : usedDeclaration
			     typeDeclaration
				 refIdentifier
				     IDENTIFIER
					 usedDerivationRule
					     semicolon
						 metaData
						     comments
{
	KWAttribute* attribute;
	KWDerivationRule* rule;

	/* Creation  et initialisation d'un attribut */
	attribute = new KWAttribute;
	attribute->SetUsed($1);
	attribute->SetType($2);

	/* Test de coherence entre le type et le complement de type dans le cas d'un type relation */
	if (KWType::IsRelation(attribute->GetType()))
	{
		if ($3 == NULL)
			yyerrorWithLineCorrection("Variable " + *($4) + " of type " + KWType::ToString($2) +
						      ": missing " + KWType::ToString($2) + " dictionary",
						  -1);
	}
	/* Test de coherence entre le type et le complement de type dans le cas d'un type Structure */
	else if (attribute->GetType() == KWType::Structure)
	{
		if ($3 == NULL)
			yyerrorWithLineCorrection("Variable " + *($4) + " of type " + KWType::ToString($2) +
						      ": missing " + KWType::ToString($2) + " dictionary",
						  -1);
	}
	/* Test d'absence de complement de type dans les autres cas */
	else
	{
		if ($3 != NULL)
			yyerrorWithLineCorrection("Variable " + *($4) + " of type " + KWType::ToString($2) +
						      ": erroneous (" + *($3) + ") type complement",
						  -1);
	}

	/* Classe referencee */
	if (KWType::IsRelation(attribute->GetType()))
	{
		KWClass* kwcReferencedClass = NULL;

		/* Test d'existence de la classe */
		if ($3 != NULL)
			kwcReferencedClass = kwcdLoadDomain->LookupClass(*($3));

		/* Sinon, test d'existence de la classe en tant que classe referencee uniquement */
		if (kwcReferencedClass == NULL and $3 != NULL)
			kwcReferencedClass = cast(KWClass*, odReferencedUncreatedClasses->Lookup(*($3)));

		/* Si la classe n'existe pas, on essaie de la creer */
		if (kwcReferencedClass == NULL and $3 != NULL)
		{
			/* Test de nom de classe */
			if (KWClass::CheckName(*($3), NULL))
			{
				kwcReferencedClass = new KWClass;
				kwcReferencedClass->SetName(*($3));

				/* Memorisation dans le dictionnaire des classe referencees */
				odReferencedUncreatedClasses->SetAt(kwcReferencedClass->GetName(), kwcReferencedClass);
			}
			else
				yyerrorWithLineCorrection("Incorrect referenced dictionary name (" + *($3) + ")", -1);
		}

		/* On memorise la classe referencee */
		attribute->SetClass(kwcReferencedClass);
	}
	/* Structure referencee */
	else if (attribute->GetType() == KWType::Structure)
	{
		if ($3 != NULL)
			attribute->SetStructureName(*($3));
	}
	if ($3 != NULL)
		delete $3;

	/* Nom de l'attribut */
	attribute->SetName(*($4));
	delete $4; /* liberation de la valeur de IDENTIFIER */
	rule = $5;
	attribute->SetDerivationRule(rule);

	/* Completion eventuelle de la regle par les infos de type de l'attribut */
	if (rule != NULL)
	{
		// Completion specifique dans le cas de la regle de gestion des references
		if (rule->GetName() == KWDerivationRule::GetReferenceRuleName() and rule->GetOperandNumber() > 0)
		{
			if (KWType::IsRelation(rule->GetType()) and
			    rule->GetObjectClassName() == "" and attribute->GetClass() != NULL)
				rule->SetObjectClassName(attribute->GetClass()->GetName());
		}

		// Completion standard
		if (KWType::IsRelation(rule->GetType()) and
		    rule->GetObjectClassName() == "" and attribute->GetClass() != NULL)
			rule->SetObjectClassName(attribute->GetClass()->GetName());

		// Erreur si type renvoye par la regle different du type de l'attribut
		if (attribute->GetType() != rule->GetType())
			yyerrorWithLineCorrection("Type of variable " + attribute->GetName() + " (" +
						      KWType::ToString(attribute->GetType()) + ") inconsistent with that returned by derivation rule " +
						      attribute->GetDerivationRule()->GetName() + " (" + KWType::ToString(attribute->GetDerivationRule()->GetType()) + ")",
						  -1);
	}

	/* Meta-donnees de l'attribut */
	if ($7 != NULL)
	{
		attribute->GetMetaData()->CopyFrom($7);
		delete $7;
	}

	/* Commentaires */
	if ($8 != NULL)
	{
		attribute->SetLabel(*($8));
		delete $8;
	}

	$$ = attribute;
};

applicationids : applicationids APPLICATIONID
{
	/* On ne garde que la premiere ligne de chaque identification d'application */
	if ($1 == NULL)
		$$ = $2;
	else
	{
		delete $2;
		$$ = $1;
	}
}
| /* NULL */
{
	$$ = NULL; /* pas d'identification d'application */
};

comments : comments LABEL
{
	/* On ne garde que la premiere ligne de chaque commentaire */
	if ($1 == NULL)
		$$ = $2;
	else
	{
		delete $2;
		$$ = $1;
	}
}
| /* NULL */
{
	$$ = NULL; /* pas de commentaire */
};

rootDeclaration : ROOT
{
	$$ = true;
}
| /* NULL */
{
	$$ = false; /* valeur par defaut */
};

usedDeclaration : UNUSED
{
	$$ = false;
}
| /* NULL */
{
	$$ = true; /* valeur par defaut */
};

typeDeclaration : CONTINUOUSTYPE
{
	$$ = KWType::Continuous;
}
| SYMBOLTYPE
{
	$$ = KWType::Symbol;
}
| DATETYPE
{
	$$ = KWType::Date;
}
| TIMETYPE
{
	$$ = KWType::Time;
}
| TIMESTAMPTYPE
{
	$$ = KWType::Timestamp;
}
| OBJECTTYPE
{
	$$ = KWType::Object;
}
| OBJECTARRAYTYPE
{
	$$ = KWType::ObjectArray;
}
| STRUCTURETYPE
{
	$$ = KWType::Structure;
};

refIdentifier : '(' IDENTIFIER ')'
{
	$$ = $2;
}
| /* NULL */
{
	$$ = NULL;
};

usedDerivationRule : '=' derivationRule
{
	$$ = $2;
}
| referenceRule
{
	$$ = $1;
}
| '=' derivationRule ')'
{
	yyerror("Too many ')'");
	$$ = $2;
}
| '(' IDENTIFIER ')'
{
	ALString sTmp;
	yyerror(sTmp + "Invalid syntax (" + *$2 + ")");
	if ($2 != NULL)
		delete $2;
	$$ = NULL;
}
| /* NULL */
{
	$$ = NULL;
};

referenceRule : referenceRuleBody ']'
{
	$$ = $1;
};

referenceRuleBody : '[' derivationRuleOperand
{
	KWDerivationRule* rule;
	KWDerivationRuleOperand* operand;

	/* Construction d'une regle pour accueillir les specifications */
	rule = KWDerivationRule::CloneDerivationRule(KWDerivationRule::GetReferenceRuleName());

	/* Destruction des operandes */
	rule->DeleteAllOperands();

	/* Ajout d'un premier operande: le premier champ de la cle de reference */
	operand = $2;
	if (operand->GetType() == KWType::Unknown)
		operand->SetType(KWType::Symbol);
	rule->AddOperand(operand);

	/* On retourner la regle */
	$$ = rule;
}
| referenceRuleBody ',' derivationRuleOperand
{
	KWDerivationRule* rule = $1;
	KWDerivationRuleOperand* operand;

	/* Ajout d'un autre operande: un autre champ de la cle de reference */
	operand = $3;
	if (operand->GetType() == KWType::Unknown)
		operand->SetType(KWType::Symbol);
	rule->AddOperand(operand);

	/* On retourner la regle */
	$$ = rule;
};

derivationRule : derivationRuleBody closeparenthesis
{
	KWDerivationRule* ruleBody = $1;
	KWDerivationRule* rule;
	KWDerivationRuleOperand* ruleBodyOperand;
	KWDerivationRuleOperand* ruleOperand;
	int i;
	boolean bRuleOk;
	ALString sTmp;

	/* Recherche de la regle de reference */
	check(ruleBody);
	rule = KWDerivationRule::CloneDerivationRule(ruleBody->GetName());

	/* Erreur si regle inexistante */
	if (rule == NULL)
	{
		yyerror("Unknown derivation rule '" + ruleBody->GetName() + "'");
	}
	/* Erreur si regle predefinie de Reference */
	else if (rule->GetName() == KWDerivationRule::GetReferenceRuleName())
	{
		yyerror("Unknown derivation rule '" + ruleBody->GetName() + "'");
		delete rule;
		rule = NULL;
	}
	/* Sinon, test du nombre d'arguments */
	else if ((rule->GetVariableOperandNumber() and
		  ruleBody->GetOperandNumber() < rule->GetOperandNumber() - 1) or
		 (not rule->GetVariableOperandNumber() and
		  ruleBody->GetOperandNumber() != rule->GetOperandNumber()))

	{
		yyerror(sTmp + "Number of operands (" +
			IntToString(ruleBody->GetOperandNumber()) +
			") inconsistent with that of rule " + rule->GetName() + " (" +
			IntToString(rule->GetOperandNumber()) + ")");
		delete rule;
		rule = NULL;
	}
	/* Verification et transfert des operandes */
	else
	{
		/* Dans le cas d'un nombre variable d'operandes, on commence par rajouter */
		/* eventuellement des operandes en fin de regle pour preparer l'instanciation */
		if (ruleBody->GetOperandNumber() > rule->GetOperandNumber())
		{
			assert(rule->GetVariableOperandNumber());
			while (rule->GetOperandNumber() < ruleBody->GetOperandNumber())
				rule->AddOperand(rule->GetOperandAt(rule->GetOperandNumber() - 1)->Clone());
		}

		/* Dans le cas d'un nombre variable d'operandes, on supprime eventuellement */
		/* le dernier operande, qui n'est pas obligatoire */
		if (ruleBody->GetOperandNumber() < rule->GetOperandNumber())
		{
			assert(rule->GetVariableOperandNumber());
			assert(ruleBody->GetOperandNumber() == rule->GetOperandNumber() - 1);
			rule->DeleteAllVariableOperands();
		}
		assert(ruleBody->GetOperandNumber() == rule->GetOperandNumber());

		/* Transfert des operandes */
		bRuleOk = true;
		for (i = 0; i < rule->GetOperandNumber(); i++)
		{
			/* acces aux operandes */
			ruleOperand = rule->GetOperandAt(i);
			ruleBodyOperand = ruleBody->GetOperandAt(i);

			/* Transfert d'informations de la regle de reference vers la regle a verifier */
			if (ruleBodyOperand->GetOrigin() != KWDerivationRuleOperand::OriginConstant)
			{
				ruleBodyOperand->SetType(ruleOperand->GetType());
				if (KWType::IsRelation(ruleOperand->GetType()))
					ruleBodyOperand->SetObjectClassName(ruleOperand->GetObjectClassName());
			}
			if (ruleOperand->GetType() == KWType::Structure)
			{
				ruleBodyOperand->SetType(KWType::Structure);
				ruleBodyOperand->SetStructureName(ruleOperand->GetStructureName());
			}

			/* Test si operande candidate valide */
			if (not ruleBodyOperand->CheckDefinition())
			{
				bRuleOk = false;
				yyerror(sTmp + "Incorrect operand " + IntToString(1 + i) + " for rule " +
					rule->GetName());
			}
			/* Test de compatibilite avec la regle enregistree, sauf si regle avec operande de type indetermine */
			else if (ruleOperand->GetType() != KWType::Unknown and not ruleBodyOperand->CheckFamily(ruleOperand))
			{
				bRuleOk = false;
				yyerror(sTmp + "Operand " + IntToString(1 + i) +
					" inconsistent with that of rule " + rule->GetName());
				break;
			}
			/* Transfert de l'origine de l'operande */
			else
			{
				/* Transfert du niveau de scope */
				ruleOperand->SetScopeLevel(ruleBodyOperand->GetScopeLevel());

				/* Transfert d'une valeur constante */
				ruleOperand->SetOrigin(ruleBodyOperand->GetOrigin());
				if (ruleOperand->GetOrigin() == KWDerivationRuleOperand::OriginConstant)
				{
					ruleOperand->SetType(ruleBodyOperand->GetType());
					ruleOperand->SetStringConstant(ruleBodyOperand->GetStringConstant());
				}
				/* Transfert d'un attribut */
				else if (ruleOperand->GetOrigin() == KWDerivationRuleOperand::OriginAttribute)
					ruleOperand->SetDataItemName(ruleBodyOperand->GetDataItemName());
				else
				/* Transfert d'une regle */
				{
					// Transfert de la regle */
					if (ruleOperand->GetDerivationRule() != NULL)
					{
						assert(ruleBodyOperand->GetDerivationRule() != NULL);
						delete ruleOperand->GetDerivationRule();
					}
					ruleOperand->SetDerivationRule(ruleBodyOperand->GetDerivationRule());

					/* Transfert des infos portees par la regle de derivation */
					if (ruleOperand->GetDerivationRule() != NULL)
					{
						ruleOperand->SetType(ruleOperand->GetDerivationRule()->GetType());
						if (KWType::IsRelation(ruleOperand->GetType()))
							ruleOperand->SetObjectClassName(ruleOperand->GetDerivationRule()->GetObjectClassName());
						if (ruleOperand->GetType() == KWType::Structure)
							ruleOperand->SetStructureName(ruleOperand->GetDerivationRule()->GetStructureName());
					}

					/* Dereferencement de la regle de derivation depuis l'operande de travail */
					ruleBodyOperand->SetDerivationRule(NULL);
				}
			}
		}

		/* Test si erreur dans le transfert des operandes */
		if (not bRuleOk)
		{
			delete rule;
			rule = NULL;
		}
		/* Sinon, on tente de compresser la regle */
		else
		{
			if (rule->IsStructureRule())
			{
				KWDRStructureRule* structureRule;

				/* Acces a la regle de structure, transformation au format structure et nettoyage memoire */
				/* Cette optimisation memoire des regles structure est critique dans le cas de dictionnaires */
				/* de tres grande taille. Sinon, des millions d'operandes de regles sont potentiellement crees, */
				/* puis lors de la compilation des dictionnaire, l'essentiel de la memoire liberee laisse des trous */
				/* dans les segments de la heap, qui ne peuvent etre rendus au systeme */
				assert(rule->CheckDefinition());
				structureRule = cast(KWDRStructureRule*, rule);
				structureRule->BuildStructureFromBase(rule);
				structureRule->CleanCompiledBaseInterface();
			}
		}
	}
	delete ruleBody;

	$$ = rule;
};

derivationRuleBody : derivationRuleBegin
{
	$$ = $1;
}
| derivationRuleHeader
{
	$$ = $1;
};

derivationRuleHeader : IDENTIFIER openparenthesis
{
	KWDerivationRule* rule;

	/* Construction d'une regle pour accueillir les specification */
	rule = new KWDerivationRule;
	rule->SetName(*($1));
	delete $1;
	$$ = rule;
};

derivationRuleBegin : derivationRuleHeader derivationRuleOperand
{
	KWDerivationRule* rule = $1;
	KWDerivationRuleOperand* operand = $2;

	check(rule);
	assert(rule->GetOperandNumber() == 0);
	check(operand);
	rule->AddOperand(operand);
	$$ = rule;
}
| derivationRuleBegin ',' derivationRuleOperand
{
	KWDerivationRule* rule = $1;
	KWDerivationRuleOperand* operand = $3;

	check(rule);
	assert(rule->GetOperandNumber() > 0);
	check(operand);
	rule->AddOperand(operand);
	$$ = rule;
};

derivationRuleOperand : IDENTIFIER
{
	KWDerivationRuleOperand* operand;
	operand = new KWDerivationRuleOperand;
	operand->SetOrigin(KWDerivationRuleOperand::OriginAttribute);
	operand->SetDataItemName(*($1));
	delete $1;
	$$ = operand;
}
| CONTINUOUSLITTERAL
{
	KWDerivationRuleOperand* operand;
	operand = new KWDerivationRuleOperand;
	operand->SetType(KWType::Continuous);
	operand->SetOrigin(KWDerivationRuleOperand::OriginConstant);
	operand->SetContinuousConstant($1);
	$$ = operand;
}
| bigstring
{
	KWDerivationRuleOperand* operand;
	operand = new KWDerivationRuleOperand;
	operand->SetType(KWType::Symbol);
	operand->SetOrigin(KWDerivationRuleOperand::OriginConstant);
	operand->SetSymbolConstant(Symbol(*($1)));
	delete $1;
	$$ = operand;
}
| derivationRule
{
	KWDerivationRuleOperand* operand;
	operand = new KWDerivationRuleOperand;
	operand->SetOrigin(KWDerivationRuleOperand::OriginRule);
	operand->SetDerivationRule($1);
	if (operand->GetDerivationRule() != NULL)
		operand->SetType(operand->GetDerivationRule()->GetType());
	$$ = operand;
}
| '.' derivationRuleOperand
{
	KWDerivationRuleOperand* operand;
	operand = $2;
	operand->SetScopeLevel(operand->GetScopeLevel() + 1);
	$$ = operand;
};

bigstring : bigstring '+' STRINGLITTERAL
{
	/* Concatenation des deux chaines */
	$$ = new ALString(*$1 + *$3);

	/* Destruction des ancienne chaines */
	delete $1;
	delete $3;
}
| STRINGLITTERAL
{
	$$ = $1;
};

semicolon : ';' | ';' ';'
{
	yyerror("There is one superfluous ';'");
}
| ';' ';' ';'
{
	yyerror("Too many ';'");
}
| /* NULL */
{
	yyerror("Missing ';'");
};

openparenthesis : '(' | '(' '('
{
	yyerror("There is one superfluous '('");
}
| '(' '(' '('
{
	yyerror("Too many '('");
}
| /* NULL */
{
	/* ERRORMGT */
	/* Attention: supprimer cette instruction en cas d'evolution du parser */
	/* Cette instruction est la pour aider au diagnostique des erreurs */
	/* de parenthesage: elle est utile dans ce cas, mais genere (avec  */
	/* sa consoeur 3 shift/reduce conflicts et 12 reduce conflicts     */
	yyerror("Missing '('");
};

closeparenthesis : ')' | /* NULL */
{
	/* ERRORMGT */
	/* Attention: supprimer cette instruction en cas d'evolution du parser */
	/* Cette instruction est la pour aider au diagnostique des erreurs */
	/* de parenthesage: elle est utile dans ce cas, mais genere (avec  */
	/* sa consoeur 3 shift/reduce conflicts et 12 reduce conflicts     */
	yyerror("Missing ')'");
};

% %

#include "KWCLex.inc"

    /* default yywrap that tells yylex to return 0 */
    int yywrap()
{
	return 1;
}

/* default yyerror for YACC and LEX */
void yyerror(char const* fmt)
{
	yyerrorWithLineCorrection(fmt, 0);
}

/* Variante avec une correction du numero de ligne */
void yyerrorWithLineCorrection(char const* fmt, int nDeltaLineNumber)
{
	char sErrorLine[20];
	ALString sLabel;
	int nLineNumber;

	nFileParsingErrorNumber++;
	nLineNumber = yylineno + nDeltaLineNumber;
	if (nLineNumber <= 0)
		nLineNumber = 1;
	sprintf(sErrorLine, "Line %d", nLineNumber);
	sLabel = fmt;
	Global::AddError("Read dictionary file",
			 sErrorLine,
			 sLabel);
}

int yyparse();

/* Implementation de la methode de lecture de fichier de KWClassDomain */
boolean KWClassDomain::ReadFile(const ALString& sFileName)
{
	boolean bOk = true;
	FILE* fFile;
	ObjectDictionary odInitialClasses;
	ObjectArray oaNewClasses;
	ObjectArray oaReferencedUncreatedClasses;
	int i;
	KWClass* kwcClass;
	ALString sLocalFileName;

	/* Affichage de stats memoire si log memoire actif */
	MemoryStatsManager::AddLog(GetClassLabel() + " " + sFileName + " ReadFile Begin");

	/* Initialisation du domaine de classe a utiliser pour le Load */
	assert(kwcdLoadDomain == NULL);
	kwcdLoadDomain = this;

	/* Initialisation de la classe courante a utiliser pour le Load */
	assert(kwcLoadCurrentClass == NULL);
	kwcLoadCurrentClass = NULL;

	/* Creation du dictionnaire des classes referencees non crees */
	assert(odReferencedUncreatedClasses == NULL);
	odReferencedUncreatedClasses = new ObjectDictionary;

	/* Erreur si pas de nom de fichier */
	fFile = NULL;
	if (sFileName == "")
	{
		AddError("Missing file name");
		bOk = false;
	}
	/* Sinon, ouverture du fichier */
	else
	{
		// Copie depuis HDFS si necessaire
		bOk = PLRemoteFileService::BuildInputWorkingFile(sFileName, sLocalFileName);
		if (bOk)
			bOk = FileService::OpenInputBinaryFile(sLocalFileName, fFile);
	}

	/* On continue si fichier ouvert correctement */
	if (bOk)
	{
		assert(fFile != NULL);

		/* Memorisation de toutes les classes initiales */
		kwcdLoadDomain->ExportClassDictionary(&odInitialClasses);

		/* Activation du nombre max d'erreurs a afficher */
		nFileParsingErrorNumber = 0;
		Global::ActivateErrorFlowControl();

		/* Positionnement du fichier a parser par la variable yyin de LEX */
		yylineno = 1;
		yyrestart(fFile);

		/* Parsing */
		yyparse();

		/* Cleaning lexer */
		yylex_destroy();

		/* Fermeture du fichier */
		FileService::CloseInputBinaryFile(sLocalFileName, fFile);

		/* Si HDFS on supprime la copie locale */
		PLRemoteFileService::CleanInputWorkingFile(sFileName, sLocalFileName);

		/* Completion des informations de type au niveau du domaine */
		if (nFileParsingErrorNumber == 0)
			kwcdLoadDomain->CompleteTypeInfo();

		/* Lecture des informations sur les attributs utilises mais non charges en memoire */
		if (nFileParsingErrorNumber == 0)
		{
			for (i = 0; i < kwcdLoadDomain->GetClassNumber(); i++)
			{
				kwcClass = kwcdLoadDomain->GetClassAt(i);
				kwcClass->ReadNotLoadedMetaData();
			}
		}

		/* Messages d'erreur pour les classes referencees non crees */
		if (nFileParsingErrorNumber > 0 or odReferencedUncreatedClasses->GetCount() > 0)
		{
			odReferencedUncreatedClasses->ExportObjectArray(&oaReferencedUncreatedClasses);
			for (i = 0; i < oaReferencedUncreatedClasses.GetSize(); i++)
			{
				kwcClass = cast(KWClass*, oaReferencedUncreatedClasses.GetAt(i));
				AddError("Error detected during parsing " + sFileName + ": dictionary " + kwcClass->GetName() + " used, but not declared");
			}
		}

		/* Desactivation du nombre max d'erreurs a afficher */
		Global::DesactivateErrorFlowControl();

		/* Destruction des classes crees si au moins une erreur de parsing detectee */
		/* ou au moins une classe referencee non cree                               */
		if (nFileParsingErrorNumber > 0 or odReferencedUncreatedClasses->GetCount() > 0)
		{
			AddError("Error detected during parsing " + sFileName + ": read operation cancelled");
			bOk = false;

			/* Recherche des nouvelles classes crees */
			for (i = 0; i < kwcdLoadDomain->GetClassNumber(); i++)
			{
				kwcClass = kwcdLoadDomain->GetClassAt(i);
				if (odInitialClasses.Lookup(kwcClass->GetName()) == NULL)
					oaNewClasses.Add(kwcClass);
			}

			/* Destruction des classes nouvellement crees */
			for (i = 0; i < oaNewClasses.GetSize(); i++)
			{
				kwcClass = cast(KWClass*, oaNewClasses.GetAt(i));
				kwcdLoadDomain->DeleteClass(kwcClass->GetName());
			}

			/* Destruction des classes referencees non crees */
			odReferencedUncreatedClasses->DeleteAll();
		}
		nFileParsingErrorNumber = 0;
	}

	/* Nettoyage */
	kwcdLoadDomain = NULL;
	kwcLoadCurrentClass = NULL;
	delete odReferencedUncreatedClasses;
	odReferencedUncreatedClasses = NULL;

	/* Affichage de stats memoire si log memoire actif */
	MemoryStatsManager::AddLog(GetClassLabel() + " " + sFileName + " ReadFile End");

	return bOk;
}
